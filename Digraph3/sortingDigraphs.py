#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Python implementation of digraphs
# Current revision $Revision$
# Copyright (C) 2006-2008  Raymond Bisdorff
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#######################
from digraphs import *
from outrankingDigraphs import *
from sortingDigraphs import *

class SortingDigraph(BipolarOutrankingDigraph,PerformanceTableau):
    """
    Specialisation of the digraphs.BipolarOutrankingDigraph Class
    for Condorcet based multicriteria sorting of alternatives.

    Besides a valid PerformanceTableau instance we require a sorting profile,
    i.e.:

         * a dictionary <categories> of categories with 'name', 'order' and 'comment'
         * a dictionary <criteriaCategoryLimits> with double entry:

               [criteriakey][categoryKey] containing a ['minimum'] and
               a  ['maximum'] value in the scale of the criterion
               respecting the order of the categories.

    Template of required data::

        self.categories = {'c01': { 'name': 'week','order': 0,
                                    'comment': 'lowest category',},
                           'c02': { 'name': 'ok','order': 1,
                                    'comment': 'medium category',},
                           'c03': { 'name': 'good','order': 2,
                                    'comment': 'highest category',},
                           'c04': { 'name': 'excellent','order': 3,
                                    'comment': 'highest category',},
        }
        self.criteriaCategoryLimits['LowerClosed'] = True # default
        self.criteriaCategoryLimits[g] = {
                'c01': {'minimum':0, 'maximum':25},
                'c02': {'minimum':25, 'maximum':50},
                'c03': {'minimum':50, 'maximum':75},
                'c04': {'minimum':75, 'maximum':120},
         }

    A template named tempProfile.py is providied in the digraphs module distribution.
        
    .. note::

        We generally require a performanceTableau instance and a filename
        where categories and a profile my be read from. If no such filename is given,
        then a default profile with five, equally spaced, categories is used
        on each criteria. By default lower-closed limts of categories are
        supposed to be used in the sorting.If no performance tableau instance is given,
        a standard random instance with 10 actions and 13 criteria is generated by default.

    Example Python3 session

    >>> from sortingDigraphs import SortingDigraph
    >>> s = SortingDigraph() %% Based on a random performance tableau 
    >>> [x for x in s.actions]
    ['a07', 'a06', 'a05', 'a04', 'a03', 'a02', 'a01', 'a10', 'a09', 'a08']
    >>> s.showSorting()
    *--- Sorting results in descending order ---*
    ]> - 100]:   []
    ]100 - 80]:  ['a03', 'a09']
    ]80 - 60]:   ['a02', 'a04', 'a05', 'a06', 'a07', 'a08']
    ]60 - 40]:   ['a01', 'a10']
    ]40 - 20]: 	 []
    ]20 - 0]:    []
    >>> s.showSortingCharacteristics('a10')
    x  in  K_k	  r(x >= m_k)	r(x < M_k)  r(x in K_k)
    a10 in [0-20[    100.00	 -85.98	      -85.98
    a10 in [20-40[    85.98	 -49.53	      -49.53
    a10 in [40-60[    49.53	  20.56	       20.56
    a10 in [60-80[   -20.56	  34.58	      -20.56
    a10 in [80-100[  -34.58	 100.00	      -34.58
    a10 in [100-<[  -100.00	 100.00	     -100.00
    >>> from outrankingDigraphs import BipolarOutrankingDigraph
    >>> g = BipolarOutrankingDigraph(s)
    >>> g.computeOrdinalCorrelation(s)
    {'determination': Decimal('0.2438213914849428868120456904'),
    'MedianCut': False,
    'correlation': Decimal('0.6482112436115843270868824533')}
    >>> 
    

    """

    def __init__(self,argPerfTab=None,
                 argProfile=None,
                 scaleSteps=5,
                 minValuation=-100.0,
                 maxValuation=100.0,
                 isRobust=False,
                 hasNoVeto=False,
                 LowerClosed=True,
                 StoreSorting=True,
                 Threading=False,
                 nbrCores=None,
                 Debug=False):
        """
        Constructor for SortingDigraph instances.

        """

        from copy import copy, deepcopy
        from decimal import Decimal
        from collections import OrderedDict

        # import the performance tableau
        if argPerfTab == None:
            perfTab = RandomPerformanceTableau(numberOfActions=10,
                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab
        # normalize the actions as a dictionary construct
        if isinstance(perfTab.actions,list):
            actions = OrderedDict()
            for x in perfTab.actions:
                actions[x] = {'name': str(x)}
            self.actions = actions
        else:
            self.actions = deepcopy(perfTab.actions)

        # keep a copy of the original actions set before adding the profiles
        self.actionsOrig = deepcopy(self.actions)

        #  input the profiles
        if argProfile != None:
            defaultProfiles = False
            self.criteria = deepcopy(perfTab.criteria)
            self.convertWeightFloatToDecimal()
            self.evaluation = deepcopy(perfTab.evaluation)
            self.convertEvaluationFloatToDecimal()
            if isinstance(argProfile,str): # input from stored instantiation
                fileName = argProfile
                fileNameExt = fileName + '.py'
                profile = OrderedDict()
                exec(compile(open(fileNameExt).read(), fileNameExt, 'exec'),profile)
                #print(profile)
                self.name = fileName
                self.categories = profile['categories']
                self.criteriaCategoryLimits = profile['criteriaCategoryLimits']
            else: # input from a profiles dictionary
                self.name = 'sorting_with_given_profile'
                self.categories = argProfile['categories'].copy()
                self.criteriaCategoryLimits = argProfile['criteriaCategoryLimits'].copy()
        else:
            defaultProfiles = True
            self.name = 'sorting_with_default_profiles'
            normPerfTab = NormalizedPerformanceTableau(perfTab)
            self.criteria = normPerfTab.criteria
            self.convertWeightFloatToDecimal()
            self.evaluation = normPerfTab.evaluation
            self.convertEvaluationFloatToDecimal()

            # supposing all criteria scales between 0.0 and 100.0

            lowValue = 0.0
            highValue = 100.00
            # with preference direction = max
            categories = OrderedDict()
            k = int(100 / scaleSteps)
            for i in range(0,100+k,k):
                categories[str(i)] = {'name':str(i), 'order':i}
            self.categories = deepcopy(categories)

            criteriaCategoryLimits = OrderedDict()
            criteriaCategoryLimits['LowerClosed'] = LowerClosed
            for g in self.criteria:
                criteriaCategoryLimits[g] = {}
                for c in categories:
                    criteriaCategoryLimits[g][c]={
                        'minimum':int(c),
                        'maximum':int(c)+k
                        }
            self.criteriaCategoryLimits = criteriaCategoryLimits
            
        # set the category limits type (LowerClosed = True is default)
        self.criteriaCategoryLimits['LowerClosed'] = LowerClosed
        #print 'LowerClosed', LowerClosed

        # add the catogory limits to the actions set
        self.profiles = {'min':{},'max':{}}
        self.profileLimits = set()
##        categoryKeys = list(self.categories.keys())
##        criterionKeys = list(self.criteria.keys())
        for c in self.categories.keys():
            cMinKey = c+'-m'
            cMaxKey = c+'-M'
            self.profileLimits.add(cMinKey)
            self.profileLimits.add(cMaxKey)
            self.actions[cMinKey] = {'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.actions[cMaxKey] = {'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            self.profiles['min'][cMinKey] = {'category': c, 'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.profiles['max'][cMaxKey] = {'category': c, 'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            for g in self.criteria.keys():
                try:
                    if self.criteria[g]['preferenceDirection'] == 'max':
                        self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                        self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))
                    elif self.criteria[g]['preferenceDirection'] == 'min':
                        if not defaultProfiles:
                            highValueg = Decimal(str(self.criteria[g]['scale'][1]))
                        else:
                            highValueg = Decimal(str(highValue))
                        #print 'highValue = ', highValue
                        self.evaluation[g][cMinKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['minimum'])))
                        self.evaluation[g][cMaxKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['maximum'])))
                    else:
                        print('===>>>>> Error')
                except:

                    self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                    self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))

        self.convertEvaluationFloatToDecimal()

        # construct outranking relation
        if isRobust:
            g = RobustOutrankingDigraph(self)
            self.valuationdomain = g.valuationdomain
            self.relation = g.relation
        else:
            Min = Decimal('%.4f' % minValuation)
            Max = Decimal('%.4f' % maxValuation)
            Med = (Max + Min)/Decimal('2.0')
            self.valuationdomain = {'min': Min, 'med':Med ,'max':Max }
            if LowerClosed:
                self.relation = BipolarOutrankingDigraph._constructRelationWithThreading(self,self.criteria,
                                                       self.evaluation,
                                                       initial=self.actionsOrig,
                                                       terminal=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                       hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        WithConcordanceRelation=False,
                                                        WithVetoCounts=False,
                                                        Debug=Debug)
            else:
                self.relation = BipolarOutrankingDigraph._constructRelationWithThreading(self,self.criteria,
                                                       self.evaluation,
                                                       terminal=self.actionsOrig,
                                                       initial=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                        hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        WithConcordanceRelation=False,
                                                        WithVetoCounts=False,
                                                        Debug=Debug)
            if LowerClosed:
                for x in self.actionsOrig.keys():
                    for y in self.actionsOrig.keys():
                        self.relation[x][y] = Med
                for x in self.profileLimits:
                    self.relation[x] = {}
                    for y in self.actions.keys():
                        self.relation[x][y] = Med
            else:
                for x in self.actionsOrig.keys():
                    self.relation[x] = {}
                    for y in self.actionsOrig.keys():
                        self.relation[x][y] = Med
                for y in self.profileLimits:
                    for x in self.actions.keys():
                        self.relation[x][y] = Med

        # compute weak ordering
        sortingRelation = self.computeSortingRelation(Debug=Debug,)
        for x in self.actionsOrig.keys():
            for y in self.actionsOrig.keys():
                self.relation[x][y] = sortingRelation[x][y]

        # reset original action set
        self.actions = self.actionsOrig

        # compute weak ordering by choosing
        # self.computeRankingByChoosing() !!! not scalable !!!
        # obsolete: replaced by self.computeWeakOrder()

        # init general digraph Data
        self.order = len(self.actions)
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()    
        
    def htmlCriteriaCategoryLimits(self,tableTitle='Category limits'):
        """
        Renders category minimum and maximum limits for each criterion
        as a html table.
        """
        s = ''
        s += '<h1>%s</h1>' % tableTitle
        s += '<table border="1">'

        criterionKeys = [x for x in self.criteria]
        categoryKeys = [x for x in self.categories]
        s += '<tr><th>Criteria</th>'
        for g in criterionKeys:
            s += '<th>%s</th>' % g
        s += '</tr>'

        for g in criterionKeys:
            s += '<tr><th>%s</th></tr>' % (g)
            s += '<tr><th>Lower limit</th>'
            for c in categoryKeys:
                #print '\t', c, (self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum'])
                s += '<td>%2.f</td>' % (self.criteriaCategoryLimits[g][c]['minimum'])
            s += '</tr>'
            s += '<tr><th>Upper limit</th>'
            for c in categoryKeys:
                #print '\t', c, (self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum'])
                s += '<td>%2.f</td>' % (self.criteriaCategoryLimits[g][c]['maximum'])
        s += '</tr>'

        s += '</table>'
        return s

    def computeSortingRelation(self,categoryContents=None,StoreSorting=True,Debug=False):
        """
        constructs a bipolar sorting relation using the category contents.
        """
        if categoryContents == None:
            categoryContents = self.computeCategoryContents(StoreSorting=True,)
        categoryKeys = self.orderedCategoryKeys()

        Max = self.valuationdomain['max']
        Med = self.valuationdomain['med']
        Min = self.valuationdomain['min']
        actions = [x for x in self.actionsOrig]
        currActions = set(actions)
        #sortedActions = set()
        sortingRelation = {}
        for x in actions:
            sortingRelation[x] = {}
            for y in actions:
                sortingRelation[x][y] = Med
                
        if Debug:
            print('categoryContents',categoryContents)
        for i in categoryKeys:
            ibch = set(categoryContents[i])
            ribch = set(currActions) - ibch
            if Debug:
                print('ibch,ribch',ibch,ribch)
            for x in ibch:
##                for y in sortedActions:
##                    sortingRelation[x][y] = Max
##                    sortingRelation[y][x] = Min                    
                for y in ibch:
                    sortingRelation[x][y] = Med
                    sortingRelation[y][x] = Med
                for y in ribch:
                    sortingRelation[x][y] = Min
                    sortingRelation[y][x] = Max
            currActions = currActions - ibch
##            sortedActions = sortedActions | ibch 
        return sortingRelation


    def showCriteriaCategoryLimits(self):
        """
        Shows category minimum and maximum limits for each criterion.
        """
        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True
        criterionKeys = [x for x in self.criteria]
        categoryKeys = [x for x in self.categories]
        for g in criterionKeys:
            print(g)
            for c in categoryKeys:
                if LowerClosed:
                    print('\t%s [%s; %s[' % (c, self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum']))
                else:
                    print('\t%s ]%s; %s]' % (c, self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum']))

    def getActionsKeys(self,action=None,withoutProfiles=True):
        """
        extract normal actions keys()
        """
        profiles_m = set([x for x in list(self.profiles['min'].keys())])
        profiles_M = set([x for x in list(self.profiles['max'].keys())])
        if action == None:
            actionsExt = set([x for x in list(self.actions.keys())])
            if withoutProfiles:
                return actionsExt - profiles_m - profiles_M
            else:
                return actionsExt | profiles_m | profiles_M
        else:
            return set([action])           

    def orderedCategoryKeys(self,Reverse=False):
        """
        Renders the ordered list of category keys
        based on self.categories['order'] numeric values.
        """
        categoriesSort = []
        for c in list(self.categories.keys()):
            categoriesSort.append((self.categories[c]['order'],c))
        categoriesSort.sort()
        orderedCategoryKeys = [x for (o,x) in categoriesSort]
        if Reverse:
            orderedCategoryKeys.reverse()
        return orderedCategoryKeys

    def computeWeakOrder(self,Descending=True,Debug=False):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        cC = self.computeCategoryContents()
        
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        if Debug:
            print(cCKeys)
        n = len(cC)
        n2 = n//2
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ) )

        if Debug:
            print(ordering)
        
        orderingList = []
        n = len(ordering)
        for i in range(n):
            x = ordering[i][0][1]
            if x != []:
                orderingList.append(x)
        for i in range(n):
            y = ordering[n-i-1][1][1]
            if y != []:
                orderingList.append(y)
                
        return orderingList

    def showOrderedRelationTable(self,direction="decreasing"):
        """
        Showing the relation table in decreasing (default) or increasing order.
        """
        if direction == "decreasing":
            Descending = True
        else:
            Descending = False

        weakOrdering = self.computeWeakOrder(Descending)
        
        actionsList = []
        for eq in weakOrdering:
            #print(eq)
            eq.sort()
            for x in eq:
                actionsList.append(x)
        if len(actionsList) != len(self.actions):
            print('Error !: missing action(s) %s in ordered table.')
            
        Digraph.showRelationTable(self,actionsSubset=actionsList,\
                                relation=self.relation,\
                                Sorted=False,\
                                ReflexiveTerms=False)

    def exportDigraphGraphViz(self,fileName=None, bestChoice=set(),worstChoice=set(),noSilent=True,graphType='png',graphSize='7,7'):
        """
        export GraphViz dot file for digraph drawing filtering.
        """
        Digraph.exportGraphViz(self, fileName=fileName,\
                               bestChoice=bestChoice,\
                               worstChoice=worstChoice,\
                               noSilent=noSilent,\
                               graphType=graphType,\
                               graphSize=graphSize)


    def exportGraphViz(self,fileName=None,direction='decreasing',\
                       noSilent=True,graphType='png',\
                       graphSize='7,7',\
                       fontSize=10,
                       relation=None,
                       Debug=False):
        """
        export GraphViz dot file for weak order (Hasse diagram) drawing
        filtering from SortingDigraph instances.
        """
        import os
        from copy import copy, deepcopy

        def _safeName(t0):
            try:
                t = t0.split(sep="-")
                t1 = t[0]
                n = len(t)
                if n > 1:
                    for i in range(1,n):
                        t1 += '%s%s' % ('_',t[i])
                return t1
            except:
                print('Error in nodeName: %s !!' % t0, type(t0))
                return t0
                
        if direction == 'decreasing':
            ordering = self.computeWeakOrder(Descending=True)
        else:
            ordering = self.computeWeakOrder(Descending=False)
        if Debug:
            print(ordering)
            
##            try:
##                rankingByChoosing = self.rankingByBestChoosing['result']
##            except:
##                self.computeRankingByBestChoosing()
##                rankingByChoosing = self.rankingByBestChoosing['result']
##        else:
            
##            try:
##                rankingByChoosing = self.rankingByLastChoosing['result']
##            except:
##                self.computeRankingByLastChoosing()
##                rankingByChoosing = self.rankingByLastChoosing['result']
        
        if noSilent:
            print('*---- exporting a dot file for GraphViz tools ---------*')
        actionKeys = [x for x in self.actions]
        n = len(actionKeys)
        if relation == None:
            relation = self.relation
        Med = self.valuationdomain['med']
        i = 0
        if fileName == None:
            name = self.name
        else:
            name = fileName
        dotName = name+'.dot'
        if noSilent:
            print('Exporting to '+dotName)
##        if bestChoice != set():
##            rankBestString = '{rank=max; '
##        if worstChoice != set():
##            rankWorstString = '{rank=min; '
        fo = open(dotName,'w')
        fo.write('digraph G {\n')
        fo.write('graph [ bgcolor = cornsilk, ordering = out, fontname = "Helvetica-Oblique",\n fontsize = 12,\n label = "')
        fo.write('\\nweakOrders module (graphviz)\\n R. Bisdorff, 2014", size="')
        fo.write(graphSize),fo.write('",fontsize=%d];\n' % fontSize)
        # nodes
        for x in actionKeys:
            try:
                nodeName = self.actions[x]['shortName']
            except:
                nodeName = str(x)
            node = '%s [shape = "circle", label = "%s", fontsize=%d];\n'\
                   % (str(_safeName(x)),_safeName(nodeName),fontSize)
            fo.write(node)
        # same ranks for Hasses equivalence classes
        k = len(ordering)
        for i in range(k):
            sameRank = '{ rank = same; '
            ich = ordering[i]
            for x in ich:
                sameRank += str(_safeName(x))+'; '
            sameRank += '}\n'
            print(i,sameRank)
            fo.write(sameRank)
        # save original relation
        originalRelation = copy(self.relation)
        self.relation = relation
        self.closeTransitive(Reverse=True)
        for i in range(k-1):
            ich = ordering[i]
            for x in ich:
                for j in range(i+1,k):
                    jch = ordering[j]
                    for y in jch:
                        #edge = 'n'+str(i+1)+'-> n'+str(i+2)+' [dir=forward,style="setlinewidth(1)",color=black, arrowhead=normal] ;\n'
                        if self.relation[x][y] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(x),_safeName(y),1,arcColor)
                            fo.write(edge)
                        elif self.relation[y][x] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(y),_safeName(x),1,arcColor)
                            fo.write(edge)
                                                  
        fo.write('}\n \n')
        fo.close()
        # restore original relation
        self.relation = copy(originalRelation)

        commandString = 'dot -Grankdir=TB -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
            #commandString = 'dot -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
        if noSilent:
            print(commandString)
        try:
            os.system(commandString)
        except:
            if noSilent:
                print('graphViz tools not avalaible! Please check installation.')

    def computeSortingCharacteristicsOld(self, action=None, Comments=False):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True

        sorting = {}
        for x in actions:
            sorting[x] = {}
            for c in categories:
                sorting[x][c] = {}
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if LowerClosed:
                    lowLimit = self.relation[x][cMinKey]
                    notHighLimit = Max - self.relation[x][cMaxKey] + Min
                else:
                    lowLimit = Max - self.relation[cMinKey][x] + Min
                    notHighLimit = self.relation[cMaxKey][x]
                if Comments:
                    print('%s in %s: low = %.2f, high = %.2f' % \
                          (x, c,lowLimit,notHighLimit), end=' ')
                categoryMembership = min(lowLimit,notHighLimit)
                sorting[x][c]['lowLimit'] = lowLimit
                sorting[x][c]['notHighLimit'] = notHighLimit
                sorting[x][c]['categoryMembership'] = categoryMembership

                if Comments:
                    print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))

        return sorting

    def computeSortingCharacteristics(self, action=None, StoreSorting=True,Comments=False, Debug=True,\
                                        Threading=False, nbrOfCPUs=None):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = list(self.getActionsKeys(action))
        na = len(actions)
            
        categories = list(self.orderedCategoryKeys())

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True
        if Threading:
            from multiprocessing import Process, active_children
            from pickle import dumps, loads, load
            from os import cpu_count
            class myThread(Process):
                def __init__(self, threadID, tempDirName, actions, catKeys,Debug):
                    Process.__init__(self)
                    self.threadID = threadID
                    self.workingDirectory = tempDirName
                    self.actions = actions
                    self.catKeys = catKeys
                    self.Debug = Debug
                def run(self):
                    from pickle import dumps, loads
                    from os import chdir
                    chdir(self.workingDirectory)
                    if self.Debug:
                        print("Starting working in %s on %s" % (self.workingDirectory, self.name))
                        print('actions,catKeys',self.actions,self.catKeys)
                    fi = open('dumpSelf.py','rb')
                    context = loads(fi.read())
                    fi.close()
                    Min = context.valuationdomain['min']
                    Max = context.valuationdomain['max']
                    sorting = {}
                    for x in self.actions:
                        sorting[x] = {}
                        for c in self.catKeys:
                            sorting[x][c] = {}
                            cMinKey= c+'-m'
                            cMaxKey= c+'-M'
                            if LowerClosed:
                                lowLimit = context.relation[x][cMinKey]
                                notHighLimit = Max - context.relation[x][cMaxKey] + Min
                            else:
                                lowLimit = Max - context.relation[cMinKey][x] + Min
                                notHighLimit = context.relation[cMaxKey][x]
                            if Debug:
                                print('%s in %s: low = %.2f, high = %.2f' % \
                                      (x, c,lowLimit,notHighLimit), end=' ')
                            categoryMembership = min(lowLimit,notHighLimit)
                            sorting[x][c]['lowLimit'] = lowLimit
                            sorting[x][c]['notHighLimit'] = notHighLimit
                            sorting[x][c]['categoryMembership'] = categoryMembership
                            if self.Debug:
                                print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'],\
                                   sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))
                        if self.Debug:
                            print(sorting[x])
                    foName = 'sorting-'+str(self.threadID)+'.py'
                    fo = open(foName,'wb')
                    fo.write(dumps(sorting,-1))
                    fo.close()
            print('Threaded computing of sorting characteristics ...')        
            from tempfile import TemporaryDirectory,mkdtemp
            tempDirName = mkdtemp()
            selfFileName = tempDirName +'/dumpSelf.py'
            if Debug:
                print('temDirName, selfFileName', tempDirName,selfFileName)
            fo = open(selfFileName,'wb')
            pd = dumps(self,-1)
            fo.write(pd)
            fo.close()

            if nbrOfCPUs == None:
                nbrOfCPUs = cpu_count()-1
            print('Nbr of actions',na)
            
            nbrOfJobs = na//nbrOfCPUs
            if nbrOfJobs*nbrOfCPUs < na:
                nbrOfJobs += 1
            print('Nbr of threads = ',nbrOfCPUs)
            print('Nbr of jobs/thread',nbrOfJobs)
            nbrOfThreads = 0
            for j in range(nbrOfCPUs):
                print('thread = %d/%d' % (j+1,nbrOfCPUs),end="...")
                start= j*nbrOfJobs
                if (j+1)*nbrOfJobs < na:
                    stop = (j+1)*nbrOfJobs
                else:
                    stop = na
                thActions = actions[start:stop]
                if Debug:
                    print(thActions)
                if thActions != []:
                    process = myThread(j,tempDirName,thActions,categories,Debug)
                    process.start()
                    nbrOfThreads += 1
            while active_children() != []:
                pass
                #sleep(1)
            print('Exit %d threads' % nbrOfThreads)
            sorting = {}
            for th in range(nbrOfThreads):
                if Debug:
                    print('job',th)
                fiName = tempDirName+'/sorting-'+str(th)+'.py'
                fi = open(fiName,'rb')
                sortingThread = loads(fi.read())
                if Debug:
                    print('sortingThread',sortingThread)
                sorting.update(sortingThread)
        # end of Threading
        else: # with out Threading 
            sorting = {}
            for x in actions:
                sorting[x] = {}
                for c in categories:
                    sorting[x][c] = {}
                    cMinKey= c+'-m'
                    cMaxKey= c+'-M'
                    if LowerClosed:
                        lowLimit = self.relation[x][cMinKey]
                        notHighLimit = Max - self.relation[x][cMaxKey] + Min
                    else:
                        lowLimit = Max - self.relation[cMinKey][x] + Min
                        notHighLimit = self.relation[cMaxKey][x]
                    if Debug:
                        print('%s in %s: low = %.2f, high = %.2f' % \
                              (x, c,lowLimit,notHighLimit), end=' ')
                    categoryMembership = min(lowLimit,notHighLimit)
                    sorting[x][c]['lowLimit'] = lowLimit
                    sorting[x][c]['notHighLimit'] = notHighLimit
                    sorting[x][c]['categoryMembership'] = categoryMembership

                    if Debug:
                        print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))
        if StoreSorting:
            self.sorting = sorting
        return sorting
    
    def showSortingCharacteristics(self, action=None):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True

        sorting = {}
        if LowerClosed:
            print('x  in  K_k\t r(x >= m_k)\t r(x < M_k)\t r(x in K_k)')
        else:
            print('x  in  K_k\t r(m_k < x)\t r(M_k >= x)\t r(x in K_k)')
        for x in actions:
            sorting[x] = {}
            for c in categories:
                sorting[x][c] = {}
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if LowerClosed:
                    lowLimit = self.relation[x][cMinKey]
                    notHighLimit = Max - self.relation[x][cMaxKey] + Min
                else:
                    lowLimit = Max - self.relation[cMinKey][x] + Min
                    notHighLimit = self.relation[cMaxKey][x]
                if LowerClosed:
                    print('%s in [%s - [\t' % (x, c), end=' ')
                else:
                    print('%s in [ - %s[\t' % (x, c), end=' ')
                categoryMembership = min(lowLimit,notHighLimit)
                sorting[x][c]['lowLimit'] = lowLimit
                sorting[x][c]['notHighLimit'] = notHighLimit
                sorting[x][c]['categoryMembership'] = categoryMembership
                print('%.2f\t\t %.2f\t\t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))

    def _computePessimisticSorting(self, Comments=False):
        """
        Returns a dictionary with category keys gathering the actions per ordered category on
        the basis of a bipolar valued outranking relation Stilde with low and high category limt profiles.

        An action x is added to cotegory c if (a Stilde c_min) > Med and a Stilde C_Max <= Med.
        """
        actions = self.getActionsKeys()
        categories = self.orderedCategoryKeys()
        Med = self.valuationdomain['med']

        sorts = {}
        for c in categories:
            sorts[c] = set()
        for x in actions:
            if Comments:
                print(x)
            for c in categories:
                overMin=True
                overMax = True
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if Comments:
                    print('\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey]))
                if self.relation[x][cMinKey] > Med:
                    overMin = True
                else:
                    break
                if self.relation[x][cMaxKey] <= Med:
                    overMax = False
                    #print '\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey])
                    sorts[c].add(x)
                    break
            if overMin and overMax:
                #print '\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey])
                sorts[c].add(x)
        if Comments:
            print('Sorting results')
            for c in self.orderedCategoryKeys():
                print('%s: %s' % (c, str(sorts[c])))
        return sorts

    def computeCategoryContents(self,Reverse=False,StoreSorting=True,Comments=False):
        """
        Computes the sorting results per category.
        """
        actions = list(self.getActionsKeys())
        actions.sort()
        try:
            sorting=self.sorting
        except:
            sorting = self.computeSortingCharacteristics(StoreSorting=StoreSorting,Comments=Comments)

        categoryContent = {}
        for c in self.orderedCategoryKeys(Reverse=Reverse):
            categoryContent[c] = []
            for x in actions:
                if sorting[x][c]['categoryMembership'] >= self.valuationdomain['med']:
                    categoryContent[c].append(x)
        if StoreSorting:
            self.categoryContent = categoryContent
        return categoryContent
                                                     
    def showSorting(self,Reverse=True,isReturningHTML=False):
        """
        Shows sorting results in decreasing or increasing (Reverse=False)
        order of the categories. If isReturningHTML is True (default = False)
        the method returns a htlm table with the sorting result.
        """
        #from string import replace
        try:
            categoryContent = self.categoryContent
        except:
            categoryContent = self.computeCategoryContents(StoreSorting=True)
        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = true
        if Reverse:
            print('\n*--- Sorting results in descending order ---*\n')
            prev_c = '>'
            if isReturningHTML:
                prev_c = '&gt;'
                html = '<h2>Sorting results in descending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
            for c in self.orderedCategoryKeys(Reverse=Reverse):
                if LowerClosed:
                    print(']%s - %s]:' % (prev_c,c), end=' ')
                    print('\t',categoryContent[c])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">]%s - %s]</td>' % (prev_c,c)
                        catString = str(categoryContent[c])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                else:
                    print('[%s - %s[:' % (prev_c,c), end=' ')
                    print('\t',categoryContent[c])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (prev_c,c)
                        catString = str(categoryContent[c])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                prev_c = c
        else:
            print('\n*--- Sorting results in ascending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in ascending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
            cat = [x for x in self.orderedCategoryKeys(Reverse=Reverse)]
            if isReturningHTML:
                cat.append('&lt;')
            else:
                cat.append('<')

            for i in range(len(cat)-1):
                if LowerClosed:
                    print('[%s - %s[:' % (cat[i],cat[i+1]), end=' ')
                    print('\t',categoryContent[cat[i]])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">]%s - %s]</td>' % (cat[i],cat[i+1])
                        catString = str(categoryContent[cat[i]])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                else:
                    print(']%s - %s]:' % (cat[i],cat[i+1]), end=' ')
                    print('\t',categoryContent[cat[i]])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (cat[i],cat[i+1])
                        catString = str(categoryContent[cat[i]])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')

        if isReturningHTML:
            html += '</table>'
            return html

    def showActionCategories(self,action,Debug=False,Comments=True,\
                             Threading=False,nbrOfCPUs=None):
        """
        Renders the union of categories in which the given action is sorted positively or null into.
        Returns a tuple : action, lowest category key, highest category key, membership credibility !
        """
        Med = self.valuationdomain['med']
        try:
            sorting = self.sorting
        except:
            sorting = self.computeSortingCharacteristics(action=action,\
                                                     Comments=Debug,\
                                                     Threading=Threading,
                                                         StoreSorting=True,
                                                     nbrOfCPUs=nbrOfCPUs)
        keys = []
        for c in self.orderedCategoryKeys():
            if sorting[action][c]['categoryMembership'] >= Med:
                if sorting[action][c]['lowLimit'] > Med:
                    lowLimit = sorting[action][c]['lowLimit']
                if sorting[action][c]['notHighLimit'] > Med:
                    notHighLimit = sorting[action][c]['notHighLimit']
                keys.append(c)
                if Debug:
                    print(action, c, sorting[action][c])
        n = len(keys)
        try:
            credibility = min(lowLimit,notHighLimit)
        except:
            credibility = Med
        if n == 0:
            return None
        elif n == 1:
            if Comments:
                print('%s - %s: %s with credibility: %.2f = min(%.2f,%.2f)' % (\
                                     self.categories[keys[0]]['lowLimit'],\
                                     self.categories[keys[0]]['highLimit'],\
                                     action,\
                                     credibility,lowLimit,notHighLimit) )
            return action,\
                    keys[0],\
                    keys[0],\
                    credibility
        else:
            if Comments:
                print('%s - %s: %s with credibility: %.2f = min(%.2f,%.2f)' % (\
                                     self.categories[keys[0]]['lowLimit'],\
                                     self.categories[keys[-1]]['highLimit'],\
                                     action,\
                                     credibility,lowLimit,notHighLimit) )
            return action,\
                    keys[0],\
                    keys[-1],\
                    credibility            

    def showActionsSortingResult(self,actionSubset=None,Debug=False):
        """
        shows the quantiles sorting result all (default) of a subset of the decision actions.
        """
        if actionSubset == None:
            actions = [x for x in self.actions]
            actions.sort()
        else:
            actions = [x for x in flatten(actionSubset)]
        print('Quantiles sorting result per decision action')
        for x in actions:
            self.showActionCategories(x,Debug=Debug)

    def saveProfilesXMCDA2(self,fileName='temp',category='XMCDA 2.0 format',user='sortinDigraphs Module (RB)',version='saved from Python session',title='Sorting categories in XMCDA-2.0 format.',variant='Rubis',valuationType='bipolar',isStringIO=False,stringNA='NA',comment='produced by saveProfilesXMCDA2()'):
        """
        Save profiles object self in XMCDA 2.0 format.
        """
        import codecs
        if not isStringIO:
            print('*----- saving sorting profiles in XMCDA 2.0 format  -------------*')
        nameExt = fileName+'.xml'
        if isStringIO:
            comment='produced by stringIO()'
            import io
            ## ms = 100 * len(self.actions) + 500 * len(self.criteria) * 20 * len(self.evaluation)
            ## print 'estimated mapped memory size = %d' % (ms)
            ##fo = mmap.mmap(-1,ms)
            fo = io.StringIO()
        else:
            #nameExt = fileName+'.xmcda2'
            fo = codecs.open(nameExt,'w',encoding='utf-8')
        fo.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        fo.write('<?xml-stylesheet type="text/xsl" href="xmcda2Rubis.xsl"?>\n')
        fo.write(str('<xmcda:XMCDA xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.decision-deck.org/2010/XMCDA-2.1.0-Rubis http://leopold-loewenheim.uni.lu/XMCDA2/XMCDA-2.1.0-Rubis.xsd" xmlns:xmcda="http://www.decision-deck.org/2010/XMCDA-2.1.0-Rubis" instanceID="void">\n'))

        # write description
        fo.write('<projectReference id="%s" name="%s">\n' % (fileName,nameExt))
        fo.write('<title>%s</title>\n' % (str(title)) )
        fo.write('<author>%s</author>\n' % (user) )
        fo.write('<version>%s</version>\n' % (version) )
        fo.write('<comment>%s</comment>\n' % (str(comment)) )
        fo.write('</projectReference>\n')


        #  save categories
        categoriesList = [x for x in self.categories]
        categoriesList.sort()
        na = len(categoriesList)
        categories = self.categories
        fo.write('<categories mcdaConcept="%s">\n' % ('categories'))
        fo.write('<description>\n')
        fo.write('<subTitle>Sorting categories.</subTitle>\n')
        fo.write('</description>\n')
        for i in range(na):
            try:
                categoryName = str(categories[categoriesList[i]]['name'])
            except:
                categoryName = categoriesList[i]
            fo.write('<category id="%s" name="%s" mcdaConcept="%s">\n' % (categoriesList[i],categoryName,'sortingCategory'))
            fo.write('<description>\n')
            fo.write('<comment>')
            try:
                fo.write(str(categories[categoriesList[i]]['comment']))
            except:
                fo.write('None')
            fo.write('</comment>\n')
            fo.write('</description>\n')
            fo.write('<type>real</type>\n')
            fo.write('<active>true</active>\n')
            fo.write('</category>\n')
        fo.write('</categories>\n')

        # save criteriaCategoryLimits
        criteriaList = [x for x in self.criteria]
        criteriaList.sort()
        categoriesList = [x for x in self.categories]
        categoriesList.sort()
        criteria = self.criteria
        fo.write('<criteriaCategoryLimits mcdaConcept="categoryProfiles">\n')
        fo.write('<description>\n')
        fo.write('<subTitle>Sorting profiles.</subTitle>\n')
        fo.write('</description>\n')
        for g in criteriaList:
            for c in categoriesList:
                try:
                    criterionName = str(criteria[g]['id'])
                except:
                    criterionName = g
                try:
                    categoryName = str(category[c]['id'])
                except:
                    categoryName = c

                fo.write('<criterionCategoryLimits id="lim_%s_%s" mcdaConcept="%s">\n' % (criterionName,categoryName,'criterionCategoryLimits' ) )
                fo.write('<description>\n')
                fo.write('<comment>%s</comment>\n' % ('No comment') )
                fo.write('<version>%s</version>\n' % ('Rubis k-sorting') )
                fo.write('</description>\n')
                fo.write('<criterionID>%s</criterionID>\n' % (criterionName) )
                fo.write('<categoryID>%s</categoryID>\n' % (categoryName) )
                fo.write('<lowLimit><real>%.2f</real></lowLimit>\n' % (self.criteriaCategoryLimits[g][c]['minimum']) )
                fo.write('<highLimit><real>%.2f</real></highLimit>\n' % (self.criteriaCategoryLimits[g][c]['maximum']) )

                fo.write('</criterionCategoryLimits>\n')
        fo.write('</criteriaCategoryLimits>\n')
        #########################
        fo.write('</xmcda:XMCDA>\n')
        if isStringIO:
            problemText = fo.getvalue()
            fo.close
            return problemText
        else:
            fo.close()
            print('File: ' + nameExt + ' saved !')

    def recodeValuation(self,newMin=-1.0,newMax=1.0,Debug=False):
        """
        Recodes the characteristic valuation domain according
        to the parameters given.

        .. note::

            Default values gives a normalized valuation domain

        """
        from copy import copy, deepcopy
        oldMax = self.valuationdomain['max']
        oldMin = self.valuationdomain['min']
        oldMed = self.valuationdomain['med']

        oldAmplitude = oldMax - oldMin
        if Debug:
            print(oldMin, oldMed, oldMax, oldAmplitude)

        newMin = Decimal(str(newMin))
        newMax = Decimal(str(newMax))
        newMed = Decimal('%.3f' % ((newMax + newMin)/Decimal('2.0')))

        newAmplitude = newMax - newMin
        if Debug:
            print(newMin, newMed, newMax, newAmplitude)

        actions = self.getActionsKeys(withoutProfiles=False)
        oldrelation = copy(self.relation)
        newrelation = {}
        for x in actions:
            newrelation[x] = {}
            for y in actions:
                if oldrelation[x][y] == oldMax:
                    newrelation[x][y] = newMax
                elif oldrelation[x][y] == oldMin:
                    newrelation[x][y] = newMin
                elif oldrelation[x][y] == oldMed:
                    newrelation[x][y] = newMed
                else:
                    newrelation[x][y] = newMin + ((self.relation[x][y] - oldMin)/oldAmplitude)*newAmplitude
                    if Debug:
                        print(x,y,self.relation[x][y],newrelation[x][y])
        # install new values in self
        self.valuationdomain['max'] = newMax
        self.valuationdomain['min'] = newMin
        self.valuationdomain['med'] = newMed
        self.valuationdomain['hasIntegerValuation'] = False

        self.relation = copy(newrelation)

#-------------
        
class QuantilesSortingDigraph(SortingDigraph):
    """
    Specialisation of the sortingDigraph Class
    for sorting of a large set of alternatives into
    quantiles delimited ordered classes.
    
    .. note::

        We generally require an PerformanceTableau instance or a valid filename.
        If none is given, then a default profile with the limiting quartiles Q0,Q1,Q2, Q3 and Q4 is used on each criteria.
        By default upper closed limits of categories are supposed to be used in the sorting.

    Example Python3 session:

    >>> from sortingDigraphs import *
    >>> t = RandomCBPerformanceTableau(numberOfActions=7,numberOfCriteria=5,
    ...                                weightDistribution='equiobjectives')
    >>> qs = QuantilesSortingBigDigraph(t,limitingQuantiles=7)
    >>> qs.showSorting()
    *--- Sorting results in descending order ---*
    ]0.86 - 1.00]: 	 []
    ]0.71 - 0.86]: 	 ['a03']
    ]0.57 - 0.71]: 	 ['a04']
    ]0.43 - 0.57]: 	 ['a04', 'a05', 'a06']
    ]0.29 - 0.43]: 	 ['a01', 'a02', 'a06', 'a07']
    ]0.14 - 0.29]: 	 []
    ]< - 0.14]: 	 []
    >>> qs.showQuantileOrdering()
    ]0.71-0.86] : ['a03']
    ]0.43-0.71] : ['a04']
    ]0.43-0.57] : ['a05']
    ]0.29-0.57] : ['a06']
    ]0.29-0.43] : ['a07', 'a02', 'a01']
    >>> qs.exportGraphViz('quantilesSorting')
    
    .. image:: quantilesSorting.png
    """
    def __init__(self,argPerfTab=None,\
                 limitingQuantiles=None,\
                 LowerClosed=False,\
                 PrefThresholds=True,\
                 hasNoVeto=False,\
                 outrankingType = "bipolar",\
                 CompleteOutranking = False,\
                 StoreSorting=False,\
                 Threading=False,\
                 nbrCores=None,\
                 Comments=False,
                 Debug=False):
        """
        Constructor for QuantilesSortingBigDigraph instances.

        """

        from copy import copy, deepcopy
        from decimal import Decimal

        # import the performance tableau
        if argPerfTab == None:
            print('Error: a valid performance tableau is required!')
##            perfTab = RandomPerformanceTableau(numberOfActions=10,
##                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab
        # normalize the actions as a dictionary construct
        if isinstance(perfTab.actions,list):
            actions = {}
            for x in perfTab.actions:
                actions[x] = {'name': str(x)}
            self.actions = actions
        else:
            self.actions = deepcopy(perfTab.actions)

        # keep a copy of the original actions set before adding the profiles
        self.actionsOrig = deepcopy(self.actions)

        #  normalizing the performance tableau
        normPerfTab = NormalizedPerformanceTableau(perfTab)
        self.criteria = copy(normPerfTab.criteria)
        self.convertWeightFloatToDecimal()
        self.evaluation = copy(normPerfTab.evaluation)
        self.convertEvaluationFloatToDecimal()
        
        #  compute the limiting quantiles
        if isinstance(limitingQuantiles,list):
            self.name = 'sorting_with_given_quantiles'
            newLimitingQuantiles = []
            for x in limitingQuantiles:
                newLimitingQuantiles.append(Decimal(str(x)))
            limitingQuantiles = newLimitingQuantiles
            if Debug:
                print('convert to decimal!',limitingQuantiles)
        else:
            limitingQuantiles = self._computeQuantiles(limitingQuantiles,Debug=Debug)
        self.limitingQuantiles = copy(limitingQuantiles)

        if Debug:
            print('limitingQuantiles',self.limitingQuantiles)

        # supposing all criteria scales between 0.0 and 100.0
        # with preference direction = max
        self.LowerClosed = LowerClosed
        lowValue = 0.0
        highValue = 100.00
        categories = {}
        k = len(limitingQuantiles)-1
        if LowerClosed:
            for i in range(0,k-1):
                categories[str(i+1)] = {'name':'[%.2f - %.2f['\
                %(limitingQuantiles[i],limitingQuantiles[i+1]),\
                                'order':i+1,\
                                'lowLimit': '[%.2f' % (limitingQuantiles[i]),
                                'highLimit': '%.2f[' % (limitingQuantiles[i+1])}
            categories[str(k)] = {'name':'[%.2f - <['\
                %(limitingQuantiles[k-1]), 'order':k,\
                                  'lowLimit': '[%.2f' % (limitingQuantiles[k-1]),\
                                  'highLimit': '<['}                 
        else:
            categories[str(1)] = {'name':']< - %.2f]'\
                %(limitingQuantiles[1]), 'order':1,
                    'highLimit': '%.2f]' % (limitingQuantiles[1]),\
                    'lowLimit': ']<'}                                  
            for i in range(1,k):
                categories[str(i+1)] = {'name':']%.2f - %.2f]'\
                %(limitingQuantiles[i],limitingQuantiles[i+1]), 'order':i+1,
                        'lowLimit': ']%.2f' % (limitingQuantiles[i]),
                        'highLimit': '%.2f]' % (limitingQuantiles[i+1])}
        self.categories = categories
        if Debug:
            print('categories',self.categories)

        criteriaCategoryLimits = {}
        criteriaCategoryLimits['LowerClosed'] = LowerClosed
        self.criteriaCategoryLimits = copy(criteriaCategoryLimits)
        for g in self.criteria:
            gQuantiles = self._computeLimitingQuantiles(g,\
                            PrefThresholds=PrefThresholds,Debug=Debug)
            if Debug:
                print(g,gQuantiles)
            criteriaCategoryLimits[g] = gQuantiles
##            for c in categories:
##                criteriaCategoryLimits[g][c]={
##                    'minimum':gQuantiles[(int(c)-1)],
##                    'maximum':gQuantiles[int(c)]
##                    }
        self.criteriaCategoryLimits = criteriaCategoryLimits
        if Debug:
            print('CriteriaCategoryLimits',self.criteriaCategoryLimits)

        # set the category limits type (LowerClosed = True is default)
        # self.criteriaCategoryLimits['LowerClosed'] = LowerClosed
        # print 'LowerClosed', LowerClosed

        # add the catogory limits to the actions set
        self.profiles = {}
        self.profileLimits = set()
        for c in list(self.categories.keys()):
            if LowerClosed:
                cKey = c+'-m'
            else:
                cKey = c+'-M'
            self.profileLimits.add(cKey)
            if LowerClosed:
                self.actions[cKey] = {'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
                self.profiles[cKey] = {'category': c, 'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            else:
                self.actions[cKey] = {'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
                self.profiles[cKey] = {'category': c, 'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            for g in list(self.criteria.keys()):
                if LowerClosed:
                    self.evaluation[g][cKey] = Decimal(str(self.criteriaCategoryLimits[g][int(c)-1]))
                else:
                    self.evaluation[g][cKey] = Decimal(str(self.criteriaCategoryLimits[g][int(c)]))
        if Debug:
            print('Profiles',self.profiles)
            print('ProfileLimits',self.profileLimits)
            
        self.convertEvaluationFloatToDecimal()

        # construct outranking relation
        self.hasNoVeto = hasNoVeto
        minValuation = -100.0
        maxValuation = 100.0
        if CompleteOutranking:
            g = BipolarOutrankingDigraph(normPerfTab,hasNoVeto=hasNoVeto,
                                         Threading=Threading)
            g.recodeValuation(minValuation,maxValuation)
            self.relationOrig = deepcopy(g.relation)
            Min = g.valuationdomain['min']
            Max = g.valuationdomain['max']
            self.valuationdomain = deepcopy(g.valuationdomain)
        else:
            Min = Decimal(str(minValuation))
            Max = Decimal(str(maxValuation))
##                Min = Decimal('-100')
##                Max = Decimal('100')
        Med = (Max + Min)/Decimal('2.0')
        self.valuationdomain = {'min': Min, 'med':Med ,'max':Max }
        if LowerClosed:
            self.relation = self._constructRelationWithThreading(self.criteria,
                                                   self.evaluation,
                                                   initial=self.actionsOrig,
                                                   terminal=self.profileLimits,
                                                   hasNoVeto=hasNoVeto,
                                                   hasBipolarVeto=True,
                                                    Threading=Threading,
                                                    nbrCores=nbrCores,
                                                    Comments=Comments)
        else:
            self.relation = self._constructRelationWithThreading(self.criteria,
                                                   self.evaluation,
                                                   terminal=self.actionsOrig,
                                                   initial=self.profileLimits,
                                                   hasNoVeto=hasNoVeto,
                                                    hasBipolarVeto=True,
                                                    Threading=Threading,
                                                    nbrCores=nbrCores,
                                                    Comments=Comments)
        if LowerClosed:
            for x in self.actionsOrig:
                for y in self.actionsOrig:
                    self.relation[x][y] = Med
            for x in self.profileLimits:
                self.relation[x] = {}
                for y in self.actions:
                    self.relation[x][y] = Med
        else:
            for x in self.actionsOrig:
                self.relation[x] = {}
                for y in self.actionsOrig:
                    self.relation[x][y] = Med
            for y in self.profileLimits:
                for x in self.actions:
                    self.relation[x][y] = Med

        # compute weak ordering
        sortingRelation = self.computeSortingRelation(StoreSorting=StoreSorting,\
                                                      Debug=Debug,Comments=Comments,\
                                                      Threading=Threading,\
                                                      nbrOfCPUs=nbrCores)
        for x in self.actionsOrig:
            for y in self.actionsOrig:
                self.relation[x][y] = sortingRelation[x][y]

        # reset original action set
        self.actions = self.actionsOrig
        self.order = len(self.actions)

        # compute weak ordering by choosing
        
##        if self.order < 20:
##            self.computeRankingByChoosing(CoDual=True)
        
        # init general digraph Data
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

    def showWeakOrder(self,Descending=True):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        from weakOrders import WeakOrder
        try:
            cC = self.categoryContent
        except:
            cC = self.computeCategoryContents(StoreSorting=True)
        
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        n = len(cC)
        n2 = n//2
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),x) ) )

##        orderingList = []
##        for i in range(n2):
##            x = ordering[i][0][1]
##            if x != []:
##                orderingList.append(x)
##        if 2*n2 < n:
##            x = ordering[i][0][1]
##            y = ordering[i][1][1]
##            if x != []:
##                orderingList.append(x)
##            if y != []:
##                orderingList.append(y)
##        for i in range(n2):
##            y = ordering[n2-i-1][1][1]
##            if y != []:
##                orderingList.append(y)
##            
        
        weakOrdering = {'result':ordering}

        WeakOrder.showWeakOrder(self,weakOrdering)

##        return orderingList

    def _computeQuantileOrdering(self,strategy=None,
                                Descending=True,
                                Debug=False):
        """
        Renders the 
        *Parameters*:
            * Descending: listing in *decreasing* (default) or *increasing* quantile order.
            * strategy: ordering in an {'optimistic' | 'pessimistic' | 'average' (default)}
              in the uppest, the lowest or the average potential quantile.
        
        """
        if strategy == None:
            strategy = self.sortingParameters['strategy']
        actionsCategories = {}
        for x in self.actions:
            a,lowCateg,highCateg,credibility =\
                     self.showActionCategories(x,Comments=Debug)
            if strategy == "optimistic":
                try:
                    actionsCategories[(int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(int(highCateg),int(lowCateg))] = [a]
            elif strategy == "pessimistic":
                try:
                    actionsCategories[(int(lowCateg),int(highCateg))].append(a)
                except:
                    actionsCategories[(int(lowCateg),int(highCateg))] = [a]
            elif strategy == "average":
                lc = float(lowCateg)
                hc = float(highCateg)
                ac = (lc+hc)/2.0
                try:
                    actionsCategories[(ac,int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(ac,int(highCateg),int(lowCateg))] = [a]
            else:  # optimistic by default
                try:
                    actionsCategories[(int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(int(highCateg),int(lowCateg))] = [a]      
                
        actionsCategIntervals = []
        for interval in actionsCategories:
            actionsCategIntervals.append([interval,\
                                          actionsCategories[interval]])
        actionsCategIntervals.sort(reverse=Descending)

        return actionsCategIntervals


    def computeQuantileOrdering(self,strategy=None,
                                Descending=True,
                                HTML=False,
                                Comments=False,
                                Debug=False):
        """
        *Parameters*:
            * Descending: listing in *decreasing* (default) or *increasing* quantile order.
            * strategy: ordering in an {'optimistic' (default) | 'pessimistic' | 'average'}
              in the uppest, the lowest or the average potential quantile.
        
        """
        if strategy == None:
            strategy = 'optimistic'
        if HTML:
            html = '<h1>Quantiles preordering</h1>'
            html += '<table style="background-color:White;" border="1">'
            html += '<tr bgcolor="#9acd32"><th>quantile limits</th>'
            html += '<th>%s sorting</th>' % strategy
            html += '</tr>'
        actionsCategories = {}
        for x in self.actions:
            a,lowCateg,highCateg,credibility =\
                     self.showActionCategories(x,Comments=Debug)
            if strategy == "optimistic":
                try:
                    actionsCategories[(int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(int(highCateg),int(lowCateg))] = [a]
            elif strategy == "pessimistic":
                try:
                    actionsCategories[(int(lowCateg),int(highCateg))].append(a)
                except:
                    actionsCategories[(int(lowCateg),int(highCateg))] = [a]
            elif strategy == "average":
                lc = float(lowCateg)
                hc = float(highCateg)
                ac = (lc+hc)/2.0
                try:
                    actionsCategories[(ac,int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(ac,int(highCateg),int(lowCateg))] = [a]
            else:  # optimistic by default
                try:
                    actionsCategories[(int(highCateg),int(lowCateg))].append(a)
                except:
                    actionsCategories[(int(highCateg),int(lowCateg))] = [a]      
                
        actionsCategIntervals = []
        for interval in actionsCategories:
            actionsCategIntervals.append([interval,\
                                          actionsCategories[interval]])
        actionsCategIntervals.sort(reverse=Descending)
        weakOrdering = []
        for item in actionsCategIntervals:
            #print(item)
            if Comments:
                if strategy == "optimistic":
                    if self.criteriaCategoryLimits['LowerClosed']:
                        if HTML:
                            html += '<tr><tdbgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][1])]['lowLimit'],\
                                                self.categories[str(item[0][0])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])
                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][1])]['lowLimit'],\
                                                self.categories[str(item[0][0])]['highLimit'],\
                                                str(item[1])) )
                    else:
                        if HTML:
                            html += '<tr><td bgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][1])]['lowLimit'],\
                                                self.categories[str(item[0][0])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])                            
                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][1])]['lowLimit'],\
                                                self.categories[str(item[0][0])]['highLimit'],\
                                                str(item[1])) )
                elif strategy == "pessimistic":
                    if self.criteriaCategoryLimits['LowerClosed']:
                        if HTML:
                            html += '<tr><td bgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][0])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])
                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][0])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'],\
                                                str(item[1])) )
                    else:
                        if HTML:
                            html += '<tr><td bgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][0])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])

                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][0])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'],\
                                                str(item[1])) )                   
                elif strategy == "average":
                    if self.criteriaCategoryLimits['LowerClosed']:
                        if HTML:
                            html += '<tr><td bgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][2])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])
                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][2])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'],\
                                                str(item[1])) )
                    else:
                        if HTML:
                            html += '<tr><td bgcolor="#FFF79B">%s-%s</td>' % (self.categories[str(item[0][2])]['lowLimit'],\
                                                self.categories[str(item[0][2])]['highLimit'])
                            html += '<td>%s</td></tr>' % str(item[1])
                        else:
                            print('%s-%s : %s' % (self.categories[str(item[0][2])]['lowLimit'],\
                                                self.categories[str(item[0][1])]['highLimit'],\
                                                str(item[1])) )
            weakOrdering.append(item[1])
        if HTML:
            html += '</table>'
            return html
        else:
            return weakOrdering

    def showQuantileOrdering(self,strategy=None):
        """
        Dummy show method for the commenting computeQuantileOrdering() method.
        """
        self.computeQuantileOrdering(strategy=strategy,Comments=True)


    def computeWeakOrder(self,Descending=True,Debug=False):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        try:
            cC = self.categoryContent
        except:
            cC = self.computeCategoryContents(StoreSorting=True)
        if Debug:
            print(cC)
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        if Debug:
            print('cCKeys',cCKeys)
        n = len(cC)
        n2 = n//2
        if Debug:
            print('n,n2',n,n2)
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if Debug:
                print('i,x,y,setx,sety',i,x,y,setx,sety)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ))
            if Debug:
                print(i, ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ) )
            if Debug:
                print('median term',( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ))
        if Debug:
            print(ordering)
        
        orderingList = []
        n = len(ordering)
        for i in range(n):
            x = ordering[i][0][1]
            if x != []:
                orderingList.append(x)
        for i in range(n):
            y = ordering[n-i-1][1][1]
            if y != []:
                orderingList.append(y)
##            
##        
##        weakOrdering = {'result':ordering}
##
##        WeakOrder.showWeakOrder(self,weakOrdering)

        return orderingList

    def showOrderedRelationTable(self,direction="decreasing"):
        """
        Showing the relation table in decreasing (default) or increasing order.
        """
        if direction == "decreasing":
            Descending = True
        else:
            Descending = False

        weakOrdering = self.computeWeakOrder(Descending)
        
        actionsList = []
        for eq in weakOrdering:
            #print(eq)
            eq.sort()
            for x in eq:
                actionsList.append(x)
        if len(actionsList) != len(self.actions):
            print('Error !: missing action(s) %s in ordered table.')
            
        Digraph.showRelationTable(self,actionsSubset=actionsList,\
                                relation=self.relation,\
                                Sorted=False,\
                                ReflexiveTerms=False)
        

    def _computeQuantiles(self,x,Debug=False):
        """
        renders the limiting quantiles
        """
        from math import floor
        if isinstance(x,int):
            n = x
        elif x == None:
            n = 4
        elif x == 'bitiles':
            n = 2
        elif x == 'tritiles':
            n = 3
        elif x == 'quartiles':
            n = 4
        elif x == 'quintiles':
            n = 5
        elif x == 'sextiles':
            n = 6
        elif x == 'septiles':
            n = 7
        elif x == 'octiles':
            n = 8
        elif x == 'deciles':
            n = 10
        elif x == 'dodeciles':
            n = 20
        elif x == 'centiles':
            n = 100
        elif x == 'automatic':
            pth = [5]
            for g in self.criteria:
                try:
                    pref = self.criteria[g]['thresholds']['ind'][0] + \
                           (self.criteria[g]['thresholds']['ind'][1]*Decimal('100'))
                    pth.append(pref)
                except:
                    pass
            amp = max(Decimal('1'),min(pth))
            n = int(floor(Decimal('100')/amp))
            if Debug:
                print('Detected preference thresholds = ',pth)
                print('amplitude, n',amp,n)

        limitingQuantiles = []
        for i in range(n+1):
            limitingQuantiles.append( Decimal(str(i)) / Decimal(str(n)) )
        self.name = 'sorting_with_%d-tile_limits' % n
        return limitingQuantiles
                                         
    def _computeLimitingQuantiles(self,g,Debug=False,PrefThresholds=True):
        """
        Renders the list of limiting quantiles on criteria g
        """
        from math import floor
        from copy import copy, deepcopy
        gValues = []
        for x in self.actionsOrig:
            if Debug:
                print('g,x,evaluation[g][x]',g,x,self.evaluation[g][x])
            if self.evaluation[g][x] != Decimal('-999'):
                gValues.append(self.evaluation[g][x])
        gValues.sort()
        if PrefThresholds:
            try:
                gPrefThrCst = self.criteria[g]['thresholds']['pref'][0]
                gPrefThrSlope = self.criteria[g]['thresholds']['pref'][1]
            except:
                gPrefThrCst = Decimal('0')
                gPrefThrSlope = Decimal('0')            
        n = len(gValues)
        if Debug:
            print('g,n,gValues',g,n,gValues)
        nf = Decimal(str(n+1))
        limitingQuantiles = copy(self.limitingQuantiles)
        limitingQuantiles.sort()
        if Debug:
            print(limitingQuantiles)
        LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        if LowerClosed:
            limitingQuantiles = limitingQuantiles[:-1]
        else:
            limitingQuantiles = limitingQuantiles[1:]
        if Debug:
            print(limitingQuantiles)
        # computing the quantiles on criterion g
        gQuantiles = []
        if LowerClosed:
            # we ignore the 1.00 quantile and replace it with +infty
            for q in self.limitingQuantiles:
                r = (Decimal(str(nf)) * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq < (n-1):
                    quantile = gValues[rq]\
                        + ((r-Decimal(str(rq)))*(gValues[rq+1]-gValues[rq]))
                    if rq > 0 and PrefThresholds:
                        quantile += gPrefThrCst + quantile*gPrefThrSlope
                else :
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('100.0')
                    else:
                        quantile = Decimal('200.0')
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)               

        else:  # upper closed categories
            # we ignore the quantile 0.0 and replace it with -\infty            
            for q in self.limitingQuantiles:
                r = (Decimal(str(nf)) * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq == 0:
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('-200.0')
                    else:
                        quantile = Decimal('-100.0')
                elif rq < (n-1):
                    quantile = gValues[rq]\
                        + ((r-Decimal(str(rq)))*(gValues[rq+1]-gValues[rq]))
                    if PrefThresholds:
                        quantile -= gPrefThrCst - quantile*gPrefThrSlope
                else:
                    if n > 0:
                        quantile = gValues[n-1]
                    else:
                        if self.criteria[g]['preferenceDirection'] == 'min':
                            quantile = Decimal('-200.0')
                        else:
                            quantile = Decimal('-100.0')     
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)
        if Debug:
            print(g,LowerClosed,self.criteria[g]['preferenceDirection'],gQuantiles)
        return gQuantiles

    def getActionsKeys(self,action=None,withoutProfiles=True):
        """
        extract normal actions keys()
        """
        profiles = set([x for x in list(self.profiles.keys())])
        if action == None:
            actionsExt = set([x for x in list(self.actions.keys())])
            if withoutProfiles:
                return actionsExt - profiles
            else:
                return actionsExt | profiles
        else:
            return set([action])           

    def computeCategoryContents(self,Reverse=False,Comments=False,StoreSorting=True,\
                                Threading=False,nbrOfCPUs=None):
        """
        Computes the sorting results per category.
        """
        actions = list(self.getActionsKeys())
        actions.sort()
        try:
            sorting = self.sorting
        except:
            sorting = self.computeSortingCharacteristics(Comments=Comments,\
                                                     StoreSorting=StoreSorting,\
                                                     Threading=Threading,\
                                                     nbrOfCPUs=nbrOfCPUs)

        categoryContent = {}
        for c in self.orderedCategoryKeys(Reverse=Reverse):
            categoryContent[c] = []
            for x in actions:
                if sorting[x][c]['categoryMembership'] >= self.valuationdomain['med']:
                    categoryContent[c].append(x)
        
        return categoryContent

    def computeSortingCharacteristics(self, action=None,Comments=False,\
                                      StoreSorting=False,Debug=False,\
                                        Threading=False, nbrOfCPUs=None):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']
        
        actions = list(self.getActionsKeys(action))
        na = len(actions)
        if Debug:
            print(actions)
            
        categories = list(self.orderedCategoryKeys())

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True
        if Threading and action==None:
            from multiprocessing import Process, active_children
            from pickle import dumps, loads, load
            from os import cpu_count
            if Comments:
                self.Debug = Debug
            class myThread(Process):
                def __init__(self, threadID, tempDirName, actions, catKeys,Debug):
                    Process.__init__(self)
                    self.threadID = threadID
                    self.workingDirectory = tempDirName
                    self.actions = actions
                    self.catKeys = catKeys
                    self.Debug = Debug
                def run(self):
                    from pickle import dumps, loads
                    from os import chdir
                    chdir(self.workingDirectory)
                    if self.Debug:
                        print("Starting working in %s on %s" % (self.workingDirectory, self.name))
                        print('actions,catKeys',self.actions,self.catKeys)
                    fi = open('dumpSelf.py','rb')
                    context = loads(fi.read())
                    fi.close()
                    Min = context.valuationdomain['min']
                    Max = context.valuationdomain['max']
                    sorting = {}
                    nq = len(context.limitingQuantiles) - 1
                    for x in self.actions:
                        sorting[x] = {}
                        for c in self.catKeys:
                            sorting[x][c] = {}
                            if LowerClosed:
                                cKey= c+'-m'
                            else:
                                cKey= c+'-M'
                            if LowerClosed:
                                lowLimit = context.relation[x][cKey]
                                if int(c) < nq:
                                    cMaxKey = str(int(c)+1)+'-m'
                                    notHighLimit = Max - context.relation[x][cMaxKey] + Min
                                else:
                                    notHighLimit = Max
                            else:
                                if int(c) > 1:
                                    cMinKey = str(int(c)-1)+'-M'
                                    lowLimit = Max - context.relation[cMinKey][x] + Min
                                else:
                                    lowLimit = Max
                                notHighLimit = context.relation[cKey][x]
##                            cMinKey= c+'-m'
##                            cMaxKey= c+'-M'
##                            if LowerClosed:
##                                lowLimit = context.relation[x][cMinKey]
##                                notHighLimit = Max - context.relation[x][cMaxKey] + Min
##                            else:
##                                lowLimit = Max - context.relation[cMinKey][x] + Min
##                                notHighLimit = context.relation[cMaxKey][x]
                            if Debug:
                                print('%s in %s: low = %.2f, high = %.2f' % \
                                      (x, c,lowLimit,notHighLimit), end=' ')
                            categoryMembership = min(lowLimit,notHighLimit)
                            sorting[x][c]['lowLimit'] = lowLimit
                            sorting[x][c]['notHighLimit'] = notHighLimit
                            sorting[x][c]['categoryMembership'] = categoryMembership
                            if self.Debug:
                                print('\t %.2f \t %.2f \t %.2f\n' % (sorting[x][c]['lowLimit'],\
                                   sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))
                        if self.Debug:
                            print(sorting[x])
                    foName = 'sorting-'+str(self.threadID)+'.py'
                    fo = open(foName,'wb')
                    fo.write(dumps(sorting,-1))
                    fo.close()
            if Comments:
                print('Threaded computing of sorting characteristics ...')        
            from tempfile import TemporaryDirectory,mkdtemp
            tempDirName = mkdtemp()
            selfFileName = tempDirName +'/dumpSelf.py'
            if Debug:
                print('temDirName, selfFileName', tempDirName,selfFileName)
            fo = open(selfFileName,'wb')
            pd = dumps(self,-1)
            fo.write(pd)
            fo.close()

            if nbrOfCPUs == None:
                nbrOfCPUs = cpu_count()-1
            if Comments:
                print('Nbr of actions',na)
            
            nbrOfJobs = na//nbrOfCPUs
            if nbrOfJobs*nbrOfCPUs < na:
                nbrOfJobs += 1
            if Comments:
                print('Nbr of threads = ',nbrOfCPUs)
                print('Nbr of jobs/thread',nbrOfJobs)
            nbrOfThreads = 0
            for j in range(nbrOfCPUs):
                if Comments:
                    print('thread = %d/%d' % (j+1,nbrOfCPUs),end="...")
                start= j*nbrOfJobs
                if (j+1)*nbrOfJobs < na:
                    stop = (j+1)*nbrOfJobs
                else:
                    stop = na
                thActions = actions[start:stop]
                if Debug:
                    print(thActions)
                if thActions != []:
                    process = myThread(j,tempDirName,thActions,categories,Debug)
                    process.start()
                    nbrOfThreads += 1
            while active_children() != []:
                pass
                #sleep(1)
            if Comments:
                print('Exit %d threads' % nbrOfThreads)
            sorting = {}
            for th in range(nbrOfThreads):
                if Debug:
                    print('job',th)
                fiName = tempDirName+'/sorting-'+str(th)+'.py'
                fi = open(fiName,'rb')
                sortingThread = loads(fi.read())
                if Debug:
                    print('sortingThread',sortingThread)
                sorting.update(sortingThread)
        # end of Threading
        else: # with out Threading 
            sorting = {}
            nq = len(self.limitingQuantiles) - 1
            for x in actions:
                sorting[x] = {}
                for c in categories:
                    sorting[x][c] = {}
                    if LowerClosed:
                        cKey= c+'-m'
                    else:
                        cKey= c+'-M'
                    if LowerClosed:
                        lowLimit = self.relation[x][cKey]
                        if int(c) < nq:
                            cMaxKey = str(int(c)+1)+'-m'
                            notHighLimit = Max - self.relation[x][cMaxKey] + Min
                        else:
                            notHighLimit = Max
                    else:
                        if int(c) > 1:
                            cMinKey = str(int(c)-1)+'-M'
                            lowLimit = Max - self.relation[cMinKey][x] + Min
                        else:
                            lowLimit = Max
                        notHighLimit = self.relation[cKey][x]
##                    cMinKey= c+'-m'
##                    cMaxKey= c+'-M'
##                    if LowerClosed:
##                        lowLimit = self.relation[x][cMinKey]
##                        notHighLimit = Max - self.relation[x][cMaxKey] + Min
##                    else:
##                        lowLimit = Max - self.relation[cMinKey][x] + Min
##                        notHighLimit = self.relation[cMaxKey][x]
                    if Comments:
                        print('%s in %s: low = %.2f, high = %.2f' % \
                              (x, c,lowLimit,notHighLimit), end=' ')
                    categoryMembership = min(lowLimit,notHighLimit)
                    sorting[x][c]['lowLimit'] = lowLimit
                    sorting[x][c]['notHighLimit'] = notHighLimit
                    sorting[x][c]['categoryMembership'] = categoryMembership

                    if Comments:
                        print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))
        if StoreSorting:
            self.sorting = sorting
        return sorting

    def computeSortingCharacteristicsOld(self, action=None, Comments=False):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True

        if Comments:
            if LowerClosed:
                print('x  in  K_k\t r(x >= m_k)\t r(x < M_k)\t r(x in K_k)')
            else:
                print('x  in  K_k\t r(m_k < x)\t r(M_k >= x)\t r(x in K_k)')

        sorting = {}
        nq = len(self.limitingQuantiles) - 1
        for x in actions:
            sorting[x] = {}
            for c in categories:
                sorting[x][c] = {}
                if LowerClosed:
                    cKey= c+'-m'
                else:
                    cKey= c+'-M'
                if LowerClosed:
                    lowLimit = self.relation[x][cKey]
                    if int(c) < nq:
                        cMaxKey = str(int(c)+1)+'-m'
                        notHighLimit = Max - self.relation[x][cMaxKey] + Min
                    else:
                        notHighLimit = Max
                else:
                    if int(c) > 1:
                        cMinKey = str(int(c)-1)+'-M'
                        lowLimit = Max - self.relation[cMinKey][x] + Min
                    else:
                        lowLimit = Max
                    notHighLimit = self.relation[cKey][x]
                #if Comments:
                #    print('%s in %s: low = %.2f, high = %.2f' % \
                #          (x, c,lowLimit,notHighLimit), end=' ')
                if Comments:
                    print('%s in %s - %s\t' % (x, self.categories[c]['lowLimit'],self.categories[c]['highLimit'],), end=' ')
                categoryMembership = min(lowLimit,notHighLimit)
                sorting[x][c]['lowLimit'] = lowLimit
                sorting[x][c]['notHighLimit'] = notHighLimit
                sorting[x][c]['categoryMembership'] = categoryMembership

                if Comments:
                    #print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))
                    print('%.2f\t\t %.2f\t\t %.2f\n' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))

        return sorting

    def showSortingCharacteristics(self, action=None):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        try:
            sorting = self.sorting
        except:
            sorting = self.computeSortingCharacteristics(action=action,StoreSorting=True)

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True
        if LowerClosed:
            print('x  in  K_k\t r(x >= m_k)\t r(x < M_k)\t r(x in K_k)')
        else:
            print('x  in  K_k\t r(m_k < x)\t r(M_k >= x)\t r(x in K_k)')

        for x in actions:
            for c in categories:
                print('%s in %s - %s\t' % (x, self.categories[c]['lowLimit'],\
                        self.categories[c]['highLimit'],), end=' ')
                print('%.2f\t\t %.2f\t\t %.2f\n' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))


    def showHTMLQuantileOrdering(self,Descending=True,strategy='optimistic'):
        """
        Shows the html version of the quantile preordering in a browser window.

        The ordring strategy is either:
            * **optimistic**, following the upper quantile limits (default),
            * **pessimistic**, following the lower quantile limits,
            * **average**, following the averag of the upper and lower quantile limits.
        """
        import webbrowser
        fileName = '/tmp/preOrdering.html'
        fo = open(fileName,'w')
        fo.write(self.computeQuantileOrdering(Descending=Descending,
                                              strategy=strategy,
                                              HTML=True,
                                              Comments=True))
        fo.close()
        url = 'file://'+fileName
        webbrowser.open_new(url)


    def showHTMLSorting(self,Reverse=True):
        """
        shows the html version of the sorting result in a browser window.
        """
        import webbrowser
        fileName = '/tmp/sorting.html'
        fo = open(fileName,'w')
        fo.write(self.showSorting(Reverse=Reverse,isReturningHTML=True))
        fo.close()
        url = 'file://'+fileName
        webbrowser.open_new(url)


    def showSorting(self,Reverse=True,isReturningHTML=False,Debug=False):
        """
        Shows sorting results in decreasing or increasing (Reverse=False)
        order of the categories. If isReturningHTML is True (default = False)
        the method returns a htlm table with the sorting result.
        
        """
        #from string import replace
        from copy import copy, deepcopy

        try:
            categoryContent = self.categoryContent
        except:
            categoryContent = self.computeCategoryContents(StoreSorting=True)

        categoryKeys = self.orderedCategoryKeys(Reverse=Reverse)
        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True

        if Reverse:
            print('\n*--- Sorting results in descending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in descending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
        else:
            print('\n*--- Sorting results in ascending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in ascending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'

        for c in categoryKeys:
            print('%s:' % (self.categories[c]['name']), end=' ')
            print('\t',categoryContent[c])
            if isReturningHTML:
                #html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (limprevc,limc)
                html += '<tr><td bgcolor="#FFF79B">%s</td>' % (self.categories[c]['name'])
                catString = str(categoryContent[c])
                html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')

        if isReturningHTML:
            html += '</table>'
            return html

    def computeSortingRelation(self,categoryContents=None,Debug=False,StoreSorting=True,
                               Threading=False,nbrOfCPUs=None,Comments=False):
        """
        constructs a bipolar sorting relation using the category contents.
        """
        try:
            categoryContents = self.categoryContent
        except:
            pass
        if categoryContents == None:
            categoryContents = self.computeCategoryContents(StoreSorting=StoreSorting,\
                                Threading=Threading,nbrOfCPUs=nbrOfCPUs,Comments=Comments)
        categoryKeys = self.orderedCategoryKeys()
        Max = self.valuationdomain['max']
        Med = self.valuationdomain['med']
        Min = self.valuationdomain['min']
        actions = [x for x in self.actionsOrig]
        currActions = set(actions)
        sortingRelation = {}
        for x in actions:
            sortingRelation[x] = {}
            for y in actions:
                sortingRelation[x][y] = Med
                
        if Debug:
            print('categoryContents',categoryContents)
        for i in categoryKeys:
            ibch = set(categoryContents[i])
            ribch = set(currActions) - ibch
            if Debug:
                print('ibch,ribch',ibch,ribch)
            for x in ibch:
                for y in ibch:
                    sortingRelation[x][y] = Med
                    sortingRelation[y][x] = Med
                for y in ribch:
                    sortingRelation[x][y] = Min
                    sortingRelation[y][x] = Max
            currActions = currActions - ibch
        return sortingRelation


#-------------
        
class _QuantilesSortingDigraph(SortingDigraph):
    """
    Specialisation of the sortingDigraph Class
    for sorting of alternatives into quantiles delimited ordered classes.

    .. warning::

        Obsolete !
        
    .. note::

        We generally require an PerformanceTableau instance or a valid filename.
        If none is given, then a default profile with the limiting quartiles Q0,Q1,Q2, Q3 and Q4 is used on each criteria.
        By default lower closed limits of categories are supposed to be used in the sorting.

    Example Python3 session:

    >>> from sortingDigraphs import *
    >>> t = RandomCBPerformanceTableau(numberOfActions=7,numberOfCriteria=5,
    ...                                weightDistribution='equiobjectives')
    >>> qs = QuantilesSortingDigraph(t,limitingQuantiles=10)
    >>> qs.showSorting()
    *--- Sorting results in descending order ---*
    [0.90 - <[: 	 []
    [0.80 - 0.90[: 	 []
    [0.70 - 0.80[: 	 []
    [0.60 - 0.70[: 	 ['a02', 'a07']
    [0.50 - 0.60[: 	 ['a02', 'a04', 'a05', 'a06']
    [0.40 - 0.50[: 	 []
    [0.30 - 0.40[: 	 []
    [0.20 - 0.30[: 	 ['a03']
    [0.10 - 0.20[: 	 ['a01']
    [0.00 - 0.10[: 	 []
    >>> qs.exportGraphViz('quantilesSorting')
    
    .. image:: quantilesSorting.png
    """

    def __init__(self,argPerfTab=None,
                 limitingQuantiles=None,
                 LowerClosed=False,
                 PrefThresholds=True,
                 hasNoVeto=False,
                 outrankingType="bipolar",
                 CompleteOutranking=True,
                 StoreSorting=True,
                 Threading=False,
                 nbrCores=None,
                 Debug=False):
        """
        Constructor for QuantilesSortingDigraph instances.

        """

        from copy import copy, deepcopy
        from decimal import Decimal

        # import the performance tableau
        if argPerfTab == None:
            perfTab = RandomPerformanceTableau(numberOfActions=10,
                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab
        # normalize the actions as a dictionary construct
        if isinstance(perfTab.actions,list):
            actions = {}
            for x in perfTab.actions:
                actions[x] = {'name': str(x)}
            self.actions = actions
        else:
            self.actions = copy(perfTab.actions)

        # keep a copy of the original actions set before adding the profiles
        self.actionsOrig = copy(self.actions)

        #  normalizing the performance tableau
        normPerfTab = NormalizedPerformanceTableau(perfTab)
        self.criteria = copy(normPerfTab.criteria)
        self.convertWeightFloatToDecimal()
        self.evaluation = copy(normPerfTab.evaluation)
        self.convertEvaluationFloatToDecimal()
        
        #  compute the limiting quantiles
        if isinstance(limitingQuantiles,list):
            self.name = 'sorting_with_given_quantiles'
            newLimitingQuantiles = []
            for x in limitingQuantiles:
                newLimitingQuantiles.append(Decimal(str(x)))
            limitingQuantiles = newLimitingQuantiles
            if Debug:
                print('convert to decimal!',limitingQuantiles)
        else:
            limitingQuantiles = self._computeQuantiles(limitingQuantiles,Debug=Debug)
        self.limitingQuantiles = limitingQuantiles

        if Debug:
            print('limitingQuantiles',self.limitingQuantiles)

        # supposing all criteria scales between 0.0 and 100.0

        lowValue = 0.0
        highValue = 100.00
        # with preference direction = max
        categories = {}
        k = len(limitingQuantiles)-1
        if LowerClosed:
            for i in range(0,k-1):
                categories[str(i+1)] = {'name':'[%.2f - %.2f['\
                %(limitingQuantiles[i],limitingQuantiles[i+1]),\
                                'order':i+1,\
                                'lowLimit': '[%.2f' % (limitingQuantiles[i]),
                                'highLimit': '%.2f[' % (limitingQuantiles[i+1])}
            categories[str(k)] = {'name':'[%.2f - <['\
                %(limitingQuantiles[k-1]), 'order':k,\
                                  'lowLimit': '[%.2f' % (limitingQuantiles[k-1]),\
                                  'highLimit': '<['}                 
        else:
            categories[str(1)] = {'name':']< - %.2f]'\
                %(limitingQuantiles[1]), 'order':1,
                    'highLimit': '%.2f]' % (limitingQuantiles[1]),\
                    'lowLimit': ']<'}                                  
            for i in range(1,k):
                categories[str(i+1)] = {'name':']%.2f - %.2f]'\
                %(limitingQuantiles[i],limitingQuantiles[i+1]), 'order':i+1,
                        'lowLimit': ']%.2f' % (limitingQuantiles[i]),
                        'highLimit': '%.2f]' % (limitingQuantiles[i+1])}
        self.categories = categories
        if Debug:
            print('categories',self.categories)

        criteriaCategoryLimits = {}
        criteriaCategoryLimits['LowerClosed'] = LowerClosed
        self.criteriaCategoryLimits = copy(criteriaCategoryLimits)
        for g in self.criteria:
            gQuantiles = self._computeLimitingQuantiles(g,\
                            PrefThresholds=PrefThresholds,Debug=Debug)                
            criteriaCategoryLimits[g] = {}
            for c in categories:
                criteriaCategoryLimits[g][c]={
                    'minimum':gQuantiles[(int(c)-1)],
                    'maximum':gQuantiles[int(c)]
                    }
        self.criteriaCategoryLimits = criteriaCategoryLimits
        if Debug:
            print('CriteriaCategoryLimits',self.criteriaCategoryLimits)

        # set the category limits type (LowerClosed = True is default)
        # self.criteriaCategoryLimits['LowerClosed'] = LowerClosed
        # print 'LowerClosed', LowerClosed

        # add the catogory limits to the actions set
        self.profiles = {'min':{},'max':{}}
        self.profileLimits = set()
        for c in list(self.categories.keys()):
            cMinKey = c+'-m'
            cMaxKey = c+'-M'
            self.profileLimits.add(cMinKey)
            self.profileLimits.add(cMaxKey)
            self.actions[cMinKey] = {'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.actions[cMaxKey] = {'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            self.profiles['min'][cMinKey] = {'category': c, 'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.profiles['max'][cMaxKey] = {'category': c, 'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            for g in list(self.criteria.keys()):
                try:
                    if self.criteria[g]['preferenceDirection'] == 'max':
                        self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                        self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))
                    elif self.criteria[g]['preferenceDirection'] == 'min':
                        if not defaultProfiles:
                            highValueg = Decimal(str(self.criteria[g]['scale'][1]))
                        else:
                            highValueg = Decimal(str(highValue))
                        #print 'highValue = ', highValue
                        self.evaluation[g][cMinKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['minimum'])))
                        self.evaluation[g][cMaxKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['maximum'])))
                    else:
                        print('===>>>>> Error')
                except:

                    self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                    self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))

        if Debug:
            print('Profiles',self.profiles)
            print('ProfileLimits',self.profileLimits)
            
        self.convertEvaluationFloatToDecimal()

        # construct outranking relation
        self.hasNoVeto = hasNoVeto
        if outrankingType == "robust":
            g = RobustOutrankingDigraph(self)
            self.valuationdomain = copy(g.valuationdomain)
            self.relation = copy(g.relation)
        elif outrankingType == "likely":
            g = StochasticBipolarOutrankingDigraph(self,
                                                   sampleSize = 50,
                                                   samplingSeed = None,
                                                   hasNoVeto = hasNoVeto,
                                                   Debug = Debug,
                                                   spread = 1.0,
                                                   likelihood = 0.9,
                                                   distribution = 'triangular')
            self.valuationdomain = copy(g.valuationdomain)
            self.relation = copy(g.relation)
            
        else:
            minValuation = -100.0
            maxValuation = 100.0
            if CompleteOutranking:
                g = BipolarOutrankingDigraph(normPerfTab,hasNoVeto=hasNoVeto)
                g.recodeValuation(minValuation,maxValuation)
                self.relationOrig = deepcopy(g.relation)
                Min = g.valuationdomain['min']
                Max = g.valuationdomain['max']
            else:
                Min = Decimal(str(minValuation))
                Max = Decimal(str(maxValuation))
##                Min = Decimal('-100')
##                Max = Decimal('100')
            Med = (Max + Min)/Decimal('2.0')
            self.valuationdomain = {'min': Min, 'med':Med ,'max':Max }
            if LowerClosed:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       initial=self.actionsOrig,
                                                       terminal=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                       hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        nbrCores=nbrCores)
            else:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       terminal=self.actionsOrig,
                                                       initial=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                        hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        nbrCores=nbrCores)
            if LowerClosed:
                for x in self.actionsOrig:
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for x in self.profileLimits:
                    self.relation[x] = {}
                    for y in self.actions:
                        self.relation[x][y] = Med
            else:
                for x in self.actionsOrig:
                    self.relation[x] = {}
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for y in self.profileLimits:
                    for x in self.actions:
                        self.relation[x][y] = Med

        # compute weak ordering
        sortingRelation = self.computeSortingRelation(StoreSorting=StoreSorting,Debug=Debug)
        for x in self.actionsOrig:
            for y in self.actionsOrig:
                self.relation[x][y] = sortingRelation[x][y]

        # reset original action set
        self.actions = self.actionsOrig
        self.order = len(self.actions)

        # compute weak ordering by choosing
        
##        if self.order < 20:
##            self.computeRankingByChoosing(CoDual=True)
        
        # init general digraph Data
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

    def showWeakOrder(self,Descending=True):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        from weakOrders import WeakOrder
        try:
            cC = self.categoryContent
        except:
            cC = self.computeCategoryContents(StoreSorting=True)
        
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        n = len(cC)
        n2 = n//2
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),x) ) )

##        orderingList = []
##        for i in range(n2):
##            x = ordering[i][0][1]
##            if x != []:
##                orderingList.append(x)
##        if 2*n2 < n:
##            x = ordering[i][0][1]
##            y = ordering[i][1][1]
##            if x != []:
##                orderingList.append(x)
##            if y != []:
##                orderingList.append(y)
##        for i in range(n2):
##            y = ordering[n2-i-1][1][1]
##            if y != []:
##                orderingList.append(y)
##            
        
        weakOrdering = {'result':ordering}

        WeakOrder.showWeakOrder(self,weakOrdering)

##        return orderingList

    def computeWeakOrder(self,Descending=True,Debug=False):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        try:
            cC = self.categoryContent
        except:
            cC = self.computeCategoryContents(StoreSorting=True)
        if Debug:
            print(cC)
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        if Debug:
            print('cCKeys',cCKeys)
        n = len(cC)
        n2 = n//2
        if Debug:
            print('n,n2',n,n2)
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if Debug:
                print('i,x,y,setx,sety',i,x,y,setx,sety)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ))
            if Debug:
                print(i, ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ) )
            if Debug:
                print('median term',( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ))
        if Debug:
            print(ordering)
        
        orderingList = []
        n = len(ordering)
        for i in range(n):
            x = ordering[i][0][1]
            if x != []:
                orderingList.append(x)
        for i in range(n):
            y = ordering[n-i-1][1][1]
            if y != []:
                orderingList.append(y)
##            
##        
##        weakOrdering = {'result':ordering}
##
##        WeakOrder.showWeakOrder(self,weakOrdering)

        return orderingList

    def showOrderedRelationTable(self,direction="decreasing"):
        """
        Showing the relation table in decreasing (default) or increasing order.
        """
        if direction == "decreasing":
            Descending = True
        else:
            Descending = False

        weakOrdering = self.computeWeakOrder(Descending)
        
        actionsList = []
        for eq in weakOrdering:
            #print(eq)
            eq.sort()
            for x in eq:
                actionsList.append(x)
        if len(actionsList) != len(self.actions):
            print('Error !: missing action(s) %s in ordered table.')
            
        Digraph.showRelationTable(self,actionsSubset=actionsList,\
                                relation=self.relation,\
                                Sorted=False,\
                                ReflexiveTerms=False)
        

    def _computeQuantiles(self,x,Debug=False):
        """
        renders the limiting quantiles
        """
        from math import floor
        if isinstance(x,int):
            n = x
        elif x == None:
            n = 4
        elif x == 'bitiles':
            n = 2
        elif x == 'tritiles':
            n = 3
        elif x == 'quartiles':
            n = 4
        elif x == 'quintiles':
            n = 5
        elif x == 'sextiles':
            n = 6
        elif x == 'septiles':
            n = 7
        elif x == 'octiles':
            n = 8
        elif x == 'deciles':
            n = 10
        elif x == 'dodeciles':
            n = 20
        elif x == 'centiles':
            n = 100
        elif x == 'automatic':
            pth = [5]
            for g in self.criteria:
                try:
                    pref = self.criteria[g]['thresholds']['ind'][0] + \
                           (self.criteria[g]['thresholds']['ind'][1]*Decimal('100'))
                    pth.append(pref)
                except:
                    pass
            amp = max(Decimal('1'),min(pth))
            n = int(floor(Decimal('100')/amp))
            if Debug:
                print('Detected preference thresholds = ',pth)
                print('amplitude, n',amp,n)

        limitingQuantiles = []
        for i in range(n+1):
            limitingQuantiles.append( Decimal(str(i)) / Decimal(str(n)) )
        self.name = 'sorting_with_%d-tile_limits' % n
        return limitingQuantiles
                                         
    def _computeLimitingQuantiles(self,g,Debug=False,PrefThresholds=True):
        """
        Renders the list of limiting quantiles on criteria g
        """
        from math import floor
        from copy import copy, deepcopy
        gValues = []
        for x in self.actionsOrig:
            if Debug:
                print('g,x,evaluation[g][x]',g,x,self.evaluation[g][x])
            if self.evaluation[g][x] != Decimal('-999'):
                gValues.append(self.evaluation[g][x])
        gValues.sort()
        if PrefThresholds:
            try:
                gPrefThrCst = self.criteria[g]['thresholds']['pref'][0]
                gPrefThrSlope = self.criteria[g]['thresholds']['pref'][1]
            except:
                gPrefThrCst = Decimal('0')
                gPrefThrSlope = Decimal('0')            
        n = len(gValues)
        if Debug:
            print('g,n,gValues',g,n,gValues)
        nf = Decimal(str(n+1))
        limitingQuantiles = copy(self.limitingQuantiles)
        limitingQuantiles.sort()
        if Debug:
            print(limitingQuantiles)
        LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        if LowerClosed:
            limitingQuantiles = limitingQuantiles[:-1]
        else:
            limitingQuantiles = limitingQuantiles[1:]
        if Debug:
            print(limitingQuantiles)
        # computing the quantiles on criterion g
        gQuantiles = []
        if LowerClosed:
            # we ignore the 1.00 quantile and replace it with +infty
            for q in self.limitingQuantiles:
                r = (Decimal(str(nf)) * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq < (n-1):
                    quantile = gValues[rq]\
                        + ((r-Decimal(str(rq)))*(gValues[rq+1]-gValues[rq]))
                    if rq > 0 and PrefThresholds:
                        quantile += gPrefThrCst + quantile*gPrefThrSlope
                else :
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('100.0')
                    else:
                        quantile = Decimal('200.0')
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)               

        else:  # upper closed categories
            # we ignore the quantile 0.0 and replace it with -\infty            
            for q in self.limitingQuantiles:
                r = (Decimal(str(nf)) * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq == 0:
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('-200.0')
                    else:
                        quantile = Decimal('-100.0')
                elif rq < (n-1):
                    quantile = gValues[rq]\
                        + ((r-Decimal(str(rq)))*(gValues[rq+1]-gValues[rq]))
                    if PrefThresholds:
                        quantile -= gPrefThrCst - quantile*gPrefThrSlope
                else:
                    if n > 0:
                        quantile = gValues[n-1]
                    else:
                        if self.criteria[g]['preferenceDirection'] == 'min':
                            quantile = Decimal('-200.0')
                        else:
                            quantile = Decimal('-100.0')                      
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)
        if Debug:
            print(g,LowerClosed,self.criteria[g]['preferenceDirection'],gQuantiles)
        return gQuantiles
                
    def showSorting(self,Reverse=True,isReturningHTML=False,Debug=False):
        """
        Shows sorting results in decreasing or increasing (Reverse=False)
        order of the categories. If isReturningHTML is True (default = False)
        the method returns a htlm table with the sorting result.
        
        """
        #from string import replace
        from copy import copy, deepcopy
        try:
            categoryContent = self.categoryContent
        except:
            categoryContent = self.computeCategoryContents(StoreSorting=True)
        categoryKeys = self.orderedCategoryKeys(Reverse=Reverse)
        try:
            LowerClosed = self.criteriaCategoryLimits['LowerClosed']
        except:
            LowerClosed = True
        if Reverse:
            print('\n*--- Sorting results in descending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in descending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
        else:
            print('\n*--- Sorting results in ascending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in ascending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
        for c in categoryKeys:
            print('%s:' % (self.categories[c]['name']), end=' ')
            print('\t',categoryContent[c])
            if isReturningHTML:
                #html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (limprevc,limc)
                html += '<tr><td bgcolor="#FFF79B">%</td>' % (self.categories[c]['name'])
                catString = str(categoryContent[c])
                html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
        if isReturningHTML:
            html += '</table>'
            return html

    def computeSortingRelation(self,categoryContents=None,Debug=False,StoreSorting=True):
        """
        constructs a bipolar sorting relation using the category contents.
        """
        try:
            categoryContents = self.categoryContent
        except:
            pass
        if categoryContents == None:
            categoryContents = self.computeCategoryContents(StoreSorting=True)
        categoryKeys = self.orderedCategoryKeys()
        Max = self.valuationdomain['max']
        Med = self.valuationdomain['med']
        Min = self.valuationdomain['min']
        actions = [x for x in self.actionsOrig]
        currActions = set(actions)
        sortingRelation = {}
        for x in actions:
            sortingRelation[x] = {}
            for y in actions:
                sortingRelation[x][y] = Med
                
        if Debug:
            print('categoryContents',categoryContents)
        for i in categoryKeys:
            ibch = set(categoryContents[i])
            ribch = set(currActions) - ibch
            if Debug:
                print('ibch,ribch',ibch,ribch)
            for x in ibch:
                for y in ibch:
                    sortingRelation[x][y] = Med
                    sortingRelation[y][x] = Med
                for y in ribch:
                    sortingRelation[x][y] = Min
                    sortingRelation[y][x] = Max
            currActions = currActions - ibch
        return sortingRelation

##class _OptimalHarmonicQuantilesSortingDigraph(QuantilesSortingDigraph):
##    """
##    Specialisation of the QuantilesSortingDigraph Class
##    for optimal sorting of alternatives into
##    quantiles delimited ordered classes. 
##    """
##    def __init__(self,argPerfTab=None,
##                 minQuantiles=4,
##                 maxQuantiles=200,
##                 LowerClosed=True,
##                 PrefThresholds=True,
##                 hasNoVeto=False,
##                 minValuation=-100.0,
##                 maxValuation=100.0,
##                 outrankingType = "bipolar",
##                 Prudent=False,
##                 Threading=False,
##                 Debug=False):
##        
##        from copy import copy as deepcopy
##        if argPerfTab != None:
##            t = argPerfTab
##        else:
##            t = RandomCBPerformanceTableau()
##        g = BipolarOutrankingDigraph(t)
##        maxCorr = {'correlation': Decimal('-1.0')}
##        maxCorr['determination'] = Decimal('0.0')
##        qs = None
##        nbrActions = len(t.actions)
##        nq = nbrActions+1
##        divNbrActions = []
##        for i in range(minQuantiles,nq):
##            if (nbrActions%i) == 0:
##                divNbrActions.append(i)
##        if Debug:
##            print(divNbrActions)
##        testNQ = [(i+1) for i in divNbrActions]
##        for m in range(2,10):
##            if m*(nbrActions+1) < maxQuantiles:
##                testNQ.append(m*(nbrActions+1))
##        if Debug:
##            print(testNQ)
##        for nq in testNQ:
##            if Debug:
##                print( '%d-tiling' % (nq) )
##            qs0 = QuantilesSortingDigraph(t,limitingQuantiles=nq,Threading=False)
##            qs0Corr = g.computeOrdinalCorrelation(qs0)
##            if Debug:
##                print( 'correlation0 = %.3f' % qs0Corr['correlation'] )
##            if Prudent:
##                if qs0Corr['correlation'] > maxCorr['correlation']:
##                    maxCorr = deepcopy(qs0Corr)
##                    maxqs = deepcopy(qs0)                
##            else:
##                if qs0Corr['correlation']*qs0Corr['determination'] > maxCorr['correlation']*maxCorr['determination']:
##                    maxCorr = deepcopy(qs0Corr)
##                    maxqs = deepcopy(qs0)
##            
##        self.name = deepcopy(maxqs.name)
##        self.actions = deepcopy(maxqs.actions)
##        self.actionsOrig = deepcopy(maxqs.actionsOrig)
##        self.order = len(self.actions)
##        self.criteria = deepcopy(maxqs.criteria)
##        self.evaluation = deepcopy(maxqs.evaluation)
##        self.profiles = deepcopy(maxqs.profiles)
##        self.valuationdomain = deepcopy(maxqs.valuationdomain)
##        self.relation = deepcopy(maxqs.relation)
##        self.categories = deepcopy(maxqs.categories)
##        self.criteriaCategoryLimits = deepcopy(maxqs.criteriaCategoryLimits)
##        self.limitingQuantiles = deepcopy(maxqs.limitingQuantiles)
##        self.gamma = self.gammaSets()
##        self.notGamma = self.notGammaSets()
           
#----------test SortingDigraph class ----------------
if __name__ == "__main__":
    from time import time
    from perfTabs import *
    from outrankingDigraphs import *
    from sortingDigraphs import *
    print("""
    ****************************************************
    * Python sortingDigraphs module                    *
    * depends on BipolarOutrankingDigraph and          *
    * $Revision$                                 *
    * Copyright (C) 2010 Raymond Bisdorff              *
    * The module comes with ABSOLUTELY NO WARRANTY     *
    * to the extent permitted by the applicable law.   *
    * This is free software, and you are welcome to    *
    * redistribute it if it remains free software.     *
    ****************************************************
    """)

    print('*-------- Testing class and methods -------')

    t = PerformanceTableau('auditor2_1')
    #t = XMCDA2PerformanceTableau('spiegel2004')
    #t = XMCDA2PerformanceTableau('ex1')
##    t = RandomCBPerformanceTableau(numberOfActions=15,
##                                   numberOfCriteria=5,
##                                   weightDistribution='equiobjectives')
##    t.saveXMCDA2('test',servingD3=False)
    #t = XMCDA2PerformanceTableau('test')  
    qs = QuantilesSortingDigraph(t,limitingQuantiles=7,LowerClosed=False,
                                     Threading=False,
                                     Debug=False)
    qs.showHTMLQuantileOrdering(strategy='average')
    qs.showSortingCharacteristics('a01')
    qs.showWeakOrder()
    qs.showQuantileOrdering(strategy=None)
    #qs.exportGraphViz('test')
    qs.showActionsSortingResult()

##    qs0 = _QuantilesSortingDigraph(t,15,LowerClosed=False,
##                                     Threading=False,
##                                     Debug=False)
##    qs0.showSorting()
##    qs0.showSortingCharacteristics('a01')
    #qs0.showWeakOrder()
    #qs.showQuantileOrdering(strategy=None)
    #qs0.exportGraphViz('test')
    #qs0.showActionsSortingResult()
    
##    qs0.showOrderedRelationTable()
##    qs0.exportGraphViz()
##    qs0.showSorting()
##    qs0.showActionsSortingResult(Debug=False)
##    qs0.computeWeakOrder(Debug=True)
##    qs0.recodeValuation()
##    qs0.showSorting()
##    qs0.showActionsSortingResult(Debug=False)
##    qs0.computeWeakOrder(Debug=True)
##    from weakOrders import QuantilesRankingDigraph
##    qsrbc = QuantilesRankingDigraph(t,3,LowerClosed=False,Threading=True)
##    qsrbc.showSorting()
##    qsrbc.showActionsSortingResult()
##    qsrbc.computeWeakOrder(Comments=True)
##    qsrbc.exportSortingGraphViz('testqs17')
##    g = BipolarOutrankingDigraph(t,Normalized=True)
##    print(g.computeOrdinalCorrelation(qs0))
##    print(g.computeOrdinalCorrelation(qsrbc))
    

    print('*------------------*')
    print('If you see this line all tests were passed successfully :-)')
    print('Enjoy !')

    print('*************************************')
    print('* R.B. december 2010                *')
    print('* $Revision$                  *')
    print('*************************************')

#############################
# Log record for changes:
# $Log: sortingDigraphs.py,v $
#############################
