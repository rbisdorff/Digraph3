#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Python implementation of digraphs
# Current revision $Revision$
# Copyright (C) 2006-2008  Raymond Bisdorff
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#######################
from digraphs import *
from outrankingDigraphs import *
from sortingDigraphs import *
#from weakOrders import *

class SortingDigraph(BipolarOutrankingDigraph,PerformanceTableau):
    """
    Specialisation of the digraphs.BipolarOutrankingDigraph Class
    for Condorcet based multicriteria sorting of alternatives.

    Besides a valid PerformanceTableau instance we require a sorting profile,
    i.e.:

         * a dictionary <categories> of categories with 'name', 'order' and 'comment'
         * a dictionary <criteriaCategoryLimits> with double entry:

               [criteriakey][categoryKey] containing a ['minimum'] and
               a  ['maximum'] value in the scale of the criterion
               respecting the order of the categories.

    Template of required data::

        self.categories = {'c01': { 'name': 'week','order': 0,
                                    'comment': 'lowest category',},
                           'c02': { 'name': 'ok','order': 1,
                                    'comment': 'medium category',},
                           'c03': { 'name': 'good','order': 2,
                                    'comment': 'highest category',},
                           'c04': { 'name': 'excellent','order': 3,
                                    'comment': 'highest category',},
        }
        self.criteriaCategoryLimits['lowerClosed'] = True # default
        self.criteriaCategoryLimits[g] = {
                'c01': {'minimum':0, 'maximum':25},
                'c02': {'minimum':25, 'maximum':50},
                'c03': {'minimum':50, 'maximum':75},
                'c04': {'minimum':75, 'maximum':120},
         }

    A template named tempProfile.py is providied in the digraphs module distribution.
        
    .. note::

        We generally require a performanceTableau instance and a filename
        where categories and a profile my be read from. If no such filename is given,
        then a default profile with five, equally spaced, categories is used
        on each criteria. By default lower-closed limts of categories are
        supposed to be used in the sorting.If no performance tableau instance is given,
        a standard random instance with 10 actions and 13 criteria is generated by default.

    Example Python3 session

    >>> from sortingDigraphs import SortingDigraph
    >>> s = SortingDigraph() %% Based on a random performance tableau 
    >>> [x for x in s.actions]
    ['a07', 'a06', 'a05', 'a04', 'a03', 'a02', 'a01', 'a10', 'a09', 'a08']
    >>> s.showSorting()
    *--- Sorting results in descending order ---*
    ]> - 100]:   []
    ]100 - 80]:  ['a03', 'a09']
    ]80 - 60]:   ['a02', 'a04', 'a05', 'a06', 'a07', 'a08']
    ]60 - 40]:   ['a01', 'a10']
    ]40 - 20]: 	 []
    ]20 - 0]:    []
    >>> s.showSortingCharacteristics('a10')
    x  in  K_k	  r(x >= m_k)	r(x < M_k)  r(x in K_k)
    a10 in [0-20[    100.00	 -85.98	      -85.98
    a10 in [20-40[    85.98	 -49.53	      -49.53
    a10 in [40-60[    49.53	  20.56	       20.56
    a10 in [60-80[   -20.56	  34.58	      -20.56
    a10 in [80-100[  -34.58	 100.00	      -34.58
    a10 in [100-<[  -100.00	 100.00	     -100.00
    >>> from outrankingDigraphs import BipolarOutrankingDigraph
    >>> g = BipolarOutrankingDigraph(s)
    >>> g.computeOrdinalCorrelation(s)
    {'determination': Decimal('0.2438213914849428868120456904'),
    'MedianCut': False,
    'correlation': Decimal('0.6482112436115843270868824533')}
    >>> 
    

    """

    def __init__(self,argPerfTab=None,
                 argProfile=None,
                 scaleSteps=5,
                 minValuation=-100.0,
                 maxValuation=100.0,
                 isRobust=False,
                 hasNoVeto=False,
                 lowerClosed=True,
                 Threading=False,
                 Debug=False):
        """
        Constructor for SortingDigraph instances.

        """

        from copy import deepcopy
        from decimal import Decimal

        # import the performance tableau
        if argPerfTab == None:
            perfTab = RandomPerformanceTableau(numberOfActions=10,
                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab
        # normalize the actions as a dictionary construct
        if isinstance(perfTab.actions,list):
            actions = {}
            for x in perfTab.actions:
                actions[x] = {'name': str(x)}
            self.actions = actions
        else:
            self.actions = deepcopy(perfTab.actions)

        # keep a copy of the original actions set before adding the profiles
        self.actionsOrig = deepcopy(self.actions)

        # actionsOrig = self.actionsOrig

        #  input the profiles
        if argProfile != None:
            defaultProfiles = False
            self.criteria = deepcopy(perfTab.criteria)
            self.convertWeightFloatToDecimal()
            self.evaluation = deepcopy(perfTab.evaluation)
            self.convertEvaluationFloatToDecimal()
            if isinstance(argProfile,str): # input from stored instantiation
                fileName = argProfile
                fileNameExt = fileName + '.py'
                profile = {}
                exec(compile(open(fileNameExt).read(), fileNameExt, 'exec'),profile)
                #print(profile)
                self.name = fileName
                self.categories = profile['categories']
                self.criteriaCategoryLimits = profile['criteriaCategoryLimits']
            else: # input from a profiles dictionary
                self.name = 'sorting_with_given_profile'
                self.categories = deepcopy(argProfile['categories'])
                self.criteriaCategoryLimits = deepcopy(argProfile['criteriaCategoryLimits'])
        else:
            defaultProfiles = True
            self.name = 'sorting_with_default_profiles'
            normPerfTab = NormalizedPerformanceTableau(perfTab)
            self.criteria = deepcopy(normPerfTab.criteria)
            self.convertWeightFloatToDecimal()
            self.evaluation = deepcopy(normPerfTab.evaluation)
            self.convertEvaluationFloatToDecimal()

            # supposing all criteria scales between 0.0 and 100.0

            lowValue = 0.0
            highValue = 100.00
            # with preference direction = max
            categories = {}
            k = int(100 / scaleSteps)
            for i in range(0,100+k,k):
                categories[str(i)] = {'name':str(i), 'order':i}
            self.categories = deepcopy(categories)

            criteriaCategoryLimits = {}
            criteriaCategoryLimits['lowerClosed'] = lowerClosed
            for g in self.criteria:
                criteriaCategoryLimits[g] = {}
                for c in categories:
                    criteriaCategoryLimits[g][c]={
                        'minimum':int(c),
                        'maximum':int(c)+k
                        }
            self.criteriaCategoryLimits = deepcopy(criteriaCategoryLimits)

        # set the category limits type (lowerClosed = True is default)
        self.criteriaCategoryLimits['lowerClosed'] = lowerClosed
        #print 'lowerClosed', lowerClosed

        # add the catogory limits to the actions set
        self.profiles = {'min':{},'max':{}}
        self.profileLimits = set()
        for c in list(self.categories.keys()):
            cMinKey = c+'-m'
            cMaxKey = c+'-M'
            self.profileLimits.add(cMinKey)
            self.profileLimits.add(cMaxKey)
            self.actions[cMinKey] = {'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.actions[cMaxKey] = {'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            self.profiles['min'][cMinKey] = {'category': c, 'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.profiles['max'][cMaxKey] = {'category': c, 'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            for g in list(self.criteria.keys()):
                try:
                    if self.criteria[g]['preferenceDirection'] == 'max':
                        self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                        self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))
                    elif self.criteria[g]['preferenceDirection'] == 'min':
                        if not defaultProfiles:
                            highValueg = Decimal(str(self.criteria[g]['scale'][1]))
                        else:
                            highValueg = Decimal(str(highValue))
                        #print 'highValue = ', highValue
                        self.evaluation[g][cMinKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['minimum'])))
                        self.evaluation[g][cMaxKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['maximum'])))
                    else:
                        print('===>>>>> Error')
                except:

                    self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                    self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))



        self.convertEvaluationFloatToDecimal()

        # construct outranking relation
        if isRobust:
            g = RobustOutrankingDigraph(self)
            self.valuationdomain = deepcopy(g.valuationdomain)
            self.relation = deepcopy(g.relation)
        else:
            Min = Decimal('%.4f' % minValuation)
            Max = Decimal('%.4f' % maxValuation)
            Med = (Max + Min)/Decimal('2.0')
            self.valuationdomain = {'min': Min, 'med':Med ,'max':Max }
            if lowerClosed:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       initial=self.actionsOrig,
                                                       terminal=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                       hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        Debug=Debug)
            else:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       terminal=self.actionsOrig,
                                                       initial=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                        hasBipolarVeto=True,
                                                        Threading=Threading,
                                                        Debug=Debug)
            if lowerClosed:
                for x in self.actionsOrig:
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for x in self.profileLimits:
                    self.relation[x] = {}
                    for y in self.actions:
                        self.relation[x][y] = Med
            else:
                for x in self.actionsOrig:
                    self.relation[x] = {}
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for y in self.profileLimits:
                    for x in self.actions:
                        self.relation[x][y] = Med

        # compute weak ordering
        sortingRelation = self.computeSortingRelation(Debug=Debug)
        for x in self.actionsOrig:
            for y in self.actionsOrig:
                self.relation[x][y] = sortingRelation[x][y]

        # reset original action set
        self.actions = deepcopy(self.actionsOrig)
        self.order = len(self.actions)

        # compute weak ordering by choosing
        # self.computeRankingByChoosing() !!! not scalable !!!
        # obsolete: replaced by self.computeWeakOrder()

        # init general digraph Data
        self.order = len(self.actions)
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

    def _constructRelation(self,criteria,\
                           evaluation,\
                           initial=None,\
                           terminal=None,\
                           hasNoVeto=False,\
                           hasBipolarVeto=True,\
                           Debug=False,\
                           hasSymmetricThresholds=True,\
                           Threading = False):
        """
        Specialization of the corresponding BipolarOutrankingDigraph method
        """
        from multiprocessing import cpu_count
        
        ##
        if not Threading or cpu_count() < 6:
            return BipolarOutrankingDigraph._constructRelation(self,criteria,\
                                    evaluation,\
                                    initial=initial,\
                                    terminal=terminal,\
                                    hasNoVeto=hasNoVeto,\
                                    hasBipolarVeto=hasBipolarVeto,\
                                    Debug=Debug,\
                                    hasSymmetricThresholds=hasSymmetricThresholds)
        ##
        else:  # parallel computation
            from copy import deepcopy
            from pickle import dumps, loads, load
            from multiprocessing import Process, Lock,\
                                        active_children, cpu_count
            #Debug=True
            class myThread(Process):
                def __init__(self, threadID,\
                             InitialSplit, tempDirName,\
                             hasNoVeto, hasBipolarVeto,\
                             hasSymmetricThresholds, Debug):
                    Process.__init__(self)
                    self.threadID = threadID
                    self.InitialSplit = InitialSplit
                    self.workingDirectory = tempDirName
                    self.hasNoVeto = hasNoVeto
                    self.hasBipolarVeto = hasBipolarVeto,
                    hasSymmetricThresholds = hasSymmetricThresholds,
                    self.Debug = Debug
                def run(self):
                    from pickle import dumps, loads
                    from os import chdir
                    chdir(self.workingDirectory)
                    if Debug:
                        print("Starting working in %s on %s" % (self.workingDirectory, self.name))
                    fi = open('dumpSelf.py','rb')
                    digraph = loads(fi.read())
                    fi.close()
                    fiName = 'splitActions-'+str(self.threadID)+'.py'
                    fi = open(fiName,'rb')
                    splitActions = loads(fi.read())
                    fi.close()
                    foName = 'splitRelation-'+str(self.threadID)+'.py'
                    fo = open(foName,'wb')
                    if self.InitialSplit:
                        splitRelation = BipolarOutrankingDigraph._constructRelation(digraph,digraph.criteria,\
                                            digraph.evaluation,\
                                            initial=splitActions,\
                                            #terminal=terminal,\
                                            hasNoVeto=hasNoVeto,\
                                            hasBipolarVeto=hasBipolarVeto,\
                                            Debug=False,\
                                            hasSymmetricThresholds=hasSymmetricThresholds)
                    else:
                        splitRelation = BipolarOutrankingDigraph._constructRelation(digraph,digraph.criteria,\
                                            digraph.evaluation,\
                                            #initial=initial,\
                                            terminal=splitActions,\
                                            hasNoVeto=hasNoVeto,\
                                            hasBipolarVeto=hasBipolarVeto,\
                                            Debug=False,\
                                            hasSymmetricThresholds=hasSymmetricThresholds)
                    fo.write(dumps(splitRelation,-1))
                    fo.close()
            
            print('Threading ...')
            from tempfile import TemporaryDirectory
            with TemporaryDirectory() as tempDirName:
                from copy import deepcopy
                selfDp = deepcopy(self)
                selfFileName = tempDirName +'/dumpSelf.py'
                if Debug:
                    print('temDirName, selfFileName', tempDirName,selfFileName)
                fo = open(selfFileName,'wb')
                pd = dumps(selfDp,-1)
                fo.write(pd)
                fo.close()
                
                nbrCores = cpu_count()-1
                print('Nbr of cpus = ',nbrCores)

                ni = len(initial)
                nt = len(terminal)
                if ni > nt:
                    n = ni
                    actions2Split = list(initial)
                    InitialSplit = True
                else:
                    n = nt
                    actions2Split = list(terminal)
                    InitialSplit = False
                if Debug:
                    print('InitialSplit, actions2Split', InitialSplit, actions2Split)
            
                nit = n//nbrCores
                if nit*nbrCores < n:
                    nbrOfJobs = nbrCores + 1
                else:
                    nbrOfJobs = nbrCores
                if Debug:
                    print('nbr of actions to split',n)
                    print('nbr of jobs = ',nbrOfJobs)    
                    print('nbr of splitActions = ',nit)

                relation = {}
                for x in initial:
                    relation[x] = {}
                    for y in terminal:
                        relation[x][y] = self.valuationdomain['med']
                i = 0
                actionsRemain = set(actions2Split)
                for j in range(nbrOfJobs):
                    print('iteration = ',j+1,end=" ")
                    splitActions=[]
                    for k in range(nit):
                        if j < (nbrOfJobs -1) and i < n:
                            splitActions.append(actions2Split[i])
                        else:
                            splitActions = list(actionsRemain)
                        i += 1
                    print(len(splitActions))
                    if Debug:
                        print(splitActions)
                    actionsRemain = actionsRemain - set(splitActions)
                    if Debug:
                        print(actionsRemain)
                    foName = tempDirName+'/splitActions-'+str(j)+'.py'
                    fo = open(foName,'wb')
                    spa = dumps(splitActions,-1)
                    fo.write(spa)
                    fo.close()
                    splitThread = myThread(j,InitialSplit,
                                           tempDirName,hasNoVeto,hasBipolarVeto,
                                           hasSymmetricThresholds,Debug)
                    splitThread.start()
                    
                while active_children() != []:
                    pass
                    
                print('Exiting computing threads')
                for j in range(nbrOfJobs):
                    if Debug:
                        print('job',j)
                    fiName = tempDirName+'/splitActions-'+str(j)+'.py'
                    fi = open(fiName,'rb')
                    splitActions = loads(fi.read())
                    if Debug:
                        print('splitActions',splitActions)
                    fi.close()
                    fiName = tempDirName+'/splitRelation-'+str(j)+'.py'
                    fi = open(fiName,'rb')
                    splitRelation = loads(fi.read())
                    if Debug:
                        print('splitRelation',splitRelation)
                    fi.close()
                    
                    if InitialSplit:
                        for x in splitActions:
                            for y in terminal:
                                relation[x][y] = splitRelation[x][y]
                    else:  
                        for x in initial:
                            for y in splitActions:
                                relation[x][y] = splitRelation[x][y]   
                return relation
    
        
    def htmlCriteriaCategoryLimits(self,tableTitle='Category limits'):
        """
        Renders category minimum and maximum limits for each criterion
        as a html table.
        """
        s = ''
        s += '<h1>%s</h1>' % tableTitle
        s += '<table border="1">'

        criterionKeys = [x for x in self.criteria]
        categoryKeys = [x for x in self.categories]
        s += '<tr><th>Criteria</th>'
        for g in criterionKeys:
            s += '<th>%s</th>' % g
        s += '</tr>'

        for g in criterionKeys:
            s += '<tr><th>%s</th></tr>' % (g)
            s += '<tr><th>Lower limit</th>'
            for c in categoryKeys:
                #print '\t', c, (self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum'])
                s += '<td>%2.f</td>' % (self.criteriaCategoryLimits[g][c]['minimum'])
            s += '</tr>'
            s += '<tr><th>Upper limit</th>'
            for c in categoryKeys:
                #print '\t', c, (self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum'])
                s += '<td>%2.f</td>' % (self.criteriaCategoryLimits[g][c]['maximum'])
        s += '</tr>'

        s += '</table>'
        return s

    def computeSortingRelation(self,categoryContents=None,Debug=False):
        """
        constructs a bipolar sorting relation using the category contents.
        """
        if categoryContents == None:
            categoryContents = self.computeCategoryContents()
        categoryKeys = self.orderedCategoryKeys()

        Max = self.valuationdomain['max']
        Med = self.valuationdomain['med']
        Min = self.valuationdomain['min']
        actions = [x for x in self.actionsOrig]
        currActions = set(actions)
        #sortedActions = set()
        sortingRelation = {}
        for x in actions:
            sortingRelation[x] = {}
            for y in actions:
                sortingRelation[x][y] = Med
                
        if Debug:
            print('categoryContents',categoryContents)
        for i in categoryKeys:
            ibch = set(categoryContents[i])
            ribch = set(currActions) - ibch
            if Debug:
                print('ibch,ribch',ibch,ribch)
            for x in ibch:
##                for y in sortedActions:
##                    sortingRelation[x][y] = Max
##                    sortingRelation[y][x] = Min                    
                for y in ibch:
                    sortingRelation[x][y] = Med
                    sortingRelation[y][x] = Med
                for y in ribch:
                    sortingRelation[x][y] = Min
                    sortingRelation[y][x] = Max
            currActions = currActions - ibch
##            sortedActions = sortedActions | ibch 
        return sortingRelation


    def showCriteriaCategoryLimits(self):
        """
        Shows category minimum and maximum limits for each criterion.
        """
        try:
            lowerClosed = self.criteriaCategoryLimits['lowerClosed']
        except:
            lowerClosed = True
        criterionKeys = [x for x in self.criteria]
        categoryKeys = [x for x in self.categories]
        for g in criterionKeys:
            print(g)
            for c in categoryKeys:
                if lowerClosed:
                    print('\t%s [%s; %s[' % (c, self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum']))
                else:
                    print('\t%s ]%s; %s]' % (c, self.criteriaCategoryLimits[g][c]['minimum'],self.criteriaCategoryLimits[g][c]['maximum']))

    def getActionsKeys(self,action=None):
        """
        extract normal actions keys()
        """
        profiles_m = set([x for x in list(self.profiles['min'].keys())])
        profiles_M = set([x for x in list(self.profiles['max'].keys())])
        if action == None:
            actionsExt = set([x for x in list(self.actions.keys())])
            return actionsExt - profiles_m - profiles_M
        else:
            return set([action])
            
            

    def orderedCategoryKeys(self,Reverse=False):
        """
        Renders the ordered list of category keys
        based on self.categories['order'] numeric values.
        """
        categoriesSort = []
        for c in list(self.categories.keys()):
            categoriesSort.append((self.categories[c]['order'],c))
        categoriesSort.sort()
        orderedCategoryKeys = [x for (o,x) in categoriesSort]
        if Reverse:
            orderedCategoryKeys.reverse()
        return orderedCategoryKeys

    def computeWeakOrder(self,Descending=True,Debug=False):
        """
        Specialisation for QuantilesSortingDigraphs.
        """
        from decimal import Decimal
        cC = self.computeCategoryContents()
        
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        if Debug:
            print(cCKeys)
        n = len(cC)
        n2 = n//2
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),[]) ) )

        if Debug:
            print(ordering)
        
        orderingList = []
        n = len(ordering)
        for i in range(n):
            x = ordering[i][0][1]
            if x != []:
                orderingList.append(x)
        for i in range(n):
            y = ordering[n-i-1][1][1]
            if y != []:
                orderingList.append(y)
                
        return orderingList

    def showOrderedRelationTable(self,direction="decreasing"):
        """
        Showing the relation table in decreasing (default) or increasing order.
        """
        if direction == "decreasing":
            Descending = True
        else:
            Descending = False

        weakOrdering = self.computeWeakOrder(Descending)
        
        actionsList = []
        for eq in weakOrdering:
            #print(eq)
            eq.sort()
            for x in eq:
                actionsList.append(x)
        if len(actionsList) != len(self.actions):
            print('Error !: missing action(s) %s in ordered table.')
            
        Digraph.showRelationTable(self,actionsSubset=actionsList,\
                                relation=self.relation,\
                                Sorted=False,\
                                ReflexiveTerms=False)

    def exportDigraphGraphViz(self,fileName=None, bestChoice=set(),worstChoice=set(),noSilent=True,graphType='png',graphSize='7,7'):
        """
        export GraphViz dot file for digraph drawing filtering.
        """
        Digraph.exportGraphViz(self, fileName=fileName,\
                               bestChoice=bestChoice,\
                               worstChoice=worstChoice,\
                               noSilent=noSilent,\
                               graphType=graphType,\
                               graphSize=graphSize)


    def exportGraphViz(self,fileName=None,direction='decreasing',\
                       noSilent=True,graphType='png',\
                       graphSize='7,7',\
                       fontSize=10, Debug=False):
        """
        export GraphViz dot file for weak order (Hasse diagram) drawing
        filtering from SortingDigraph instances.
        """
        import os
        from copy import deepcopy

        def _safeName(t0):
            try:
                t = t0.split(sep="-")
                t1 = t[0]
                n = len(t)
                if n > 1:
                    for i in range(1,n):
                        t1 += '%s%s' % ('_',t[i])
                return t1
            except:
                print('Error in nodeName: %s !!' % t0, type(t0))
                return t0
                
        if direction == 'decreasing':
            ordering = self.computeWeakOrder(Descending=True)
        else:
            ordering = self.computeWeakOrder(Descending=False)
        if Debug:
            print(ordering)
            
##            try:
##                rankingByChoosing = self.rankingByBestChoosing['result']
##            except:
##                self.computeRankingByBestChoosing()
##                rankingByChoosing = self.rankingByBestChoosing['result']
##        else:
            
##            try:
##                rankingByChoosing = self.rankingByLastChoosing['result']
##            except:
##                self.computeRankingByLastChoosing()
##                rankingByChoosing = self.rankingByLastChoosing['result']
        
        if noSilent:
            print('*---- exporting a dot file for GraphViz tools ---------*')
        actionKeys = [x for x in self.actions]
        n = len(actionKeys)
        relation = self.relation
        Med = self.valuationdomain['med']
        i = 0
        if fileName == None:
            name = self.name
        else:
            name = fileName
        dotName = name+'.dot'
        if noSilent:
            print('Exporting to '+dotName)
##        if bestChoice != set():
##            rankBestString = '{rank=max; '
##        if worstChoice != set():
##            rankWorstString = '{rank=min; '
        fo = open(dotName,'w')
        fo.write('digraph G {\n')
        fo.write('graph [ bgcolor = cornsilk, ordering = out, fontname = "Helvetica-Oblique",\n fontsize = 12,\n label = "')
        fo.write('\\nweakOrders module (graphviz)\\n R. Bisdorff, 2014", size="')
        fo.write(graphSize),fo.write('",fontsize=%d];\n' % fontSize)
        # nodes
        for x in actionKeys:
            try:
                nodeName = self.actions[x]['shortName']
            except:
                nodeName = str(x)
            node = '%s [shape = "circle", label = "%s", fontsize=%d];\n'\
                   % (str(_safeName(x)),_safeName(nodeName),fontSize)
            fo.write(node)
        # same ranks for Hasses equivalence classes
        k = len(ordering)
        for i in range(k):
            sameRank = '{ rank = same; '
            ich = ordering[i]
            for x in ich:
                sameRank += str(_safeName(x))+'; '
            sameRank += '}\n'
            print(i,sameRank)
            fo.write(sameRank)
        # save original relation
        originalRelation = deepcopy(self.relation)
        
        self.closeTransitive(Reverse=True)
        for i in range(k-1):
            ich = ordering[i]
            for x in ich:
                for j in range(i+1,k):
                    jch = ordering[j]
                    for y in jch:
                        #edge = 'n'+str(i+1)+'-> n'+str(i+2)+' [dir=forward,style="setlinewidth(1)",color=black, arrowhead=normal] ;\n'
                        if self.relation[x][y] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(x),_safeName(y),1,arcColor)
                            fo.write(edge)
                        elif self.relation[y][x] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(y),_safeName(x),1,arcColor)
                            fo.write(edge)
                                                  
        fo.write('}\n \n')
        fo.close()
        # restore original relation
        self.relation = deepcopy(originalRelation)
        
        commandString = 'dot -Grankdir=TB -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
            #commandString = 'dot -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
        if noSilent:
            print(commandString)
        try:
            os.system(commandString)
        except:
            if noSilent:
                print('graphViz tools not avalaible! Please check installation.')


    def computeSortingCharacteristics(self, action=None, Comments=False):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            lowerClosed = self.criteriaCategoryLimits['lowerClosed']
        except:
            lowerClosed = True

        sorting = {}
        for x in actions:
            sorting[x] = {}
            for c in categories:
                sorting[x][c] = {}
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if lowerClosed:
                    lowLimit = self.relation[x][cMinKey]
                    notHighLimit = Max - self.relation[x][cMaxKey] + Min
                else:
                    lowLimit = Max - self.relation[cMinKey][x] + Min
                    notHighLimit = self.relation[cMaxKey][x]
                if Comments:
                    print('%s in %s: low = %.2f, high = %.2f' % \
                          (x, c,lowLimit,notHighLimit), end=' ')
                categoryMembership = min(lowLimit,notHighLimit)
                sorting[x][c]['lowLimit'] = lowLimit
                sorting[x][c]['notHighLimit'] = notHighLimit
                sorting[x][c]['categoryMembership'] = categoryMembership

                if Comments:
                    print('\t %.2f \t %.2f \t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))

        return sorting

    def showSortingCharacteristics(self, action=None):
        """
        Renders a bipolar-valued bi-dictionary relation
        representing the degree of credibility of the
        assertion that "action x in A belongs to category c in C",
        ie x outranks low category limit and does not outrank
        the high category limit.
        """
        Min = self.valuationdomain['min']
        Med = self.valuationdomain['med']
        Max = self.valuationdomain['max']

        actions = self.getActionsKeys(action)
            
        categories = self.orderedCategoryKeys()

        try:
            LowerClosed = self.criteriaCategoryLimits['lowerClosed']
        except:
            LowerClosed = True

        sorting = {}
        if LowerClosed:
            print('x  in  K_k\t r(x >= m_k)\t r(x < M_k)\t r(x in K_k)')
        else:
            print('x  in  K_k\t r(m_k < x)\t r(M_k >= x)\t r(x in K_k)')
        for x in actions:
            sorting[x] = {}
            for c in categories:
                sorting[x][c] = {}
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if LowerClosed:
                    lowLimit = self.relation[x][cMinKey]
                    notHighLimit = Max - self.relation[x][cMaxKey] + Min
                else:
                    lowLimit = Max - self.relation[cMinKey][x] + Min
                    notHighLimit = self.relation[cMaxKey][x]
                if LowerClosed:
                    print('%s in [%s - [\t' % (x, c), end=' ')
                else:
                    print('%s in [ - %s[\t' % (x, c), end=' ')
                categoryMembership = min(lowLimit,notHighLimit)
                sorting[x][c]['lowLimit'] = lowLimit
                sorting[x][c]['notHighLimit'] = notHighLimit
                sorting[x][c]['categoryMembership'] = categoryMembership
                print('%.2f\t\t %.2f\t\t %.2f' % (sorting[x][c]['lowLimit'], sorting[x][c]['notHighLimit'], sorting[x][c]['categoryMembership']))

    def _computePessimisticSorting(self, Comments=False):
        """
        Returns a dictionary with category keys gathering the actions per ordered category on
        the basis of a bipolar valued outranking relation Stilde with low and high category limt profiles.

        An action x is added to cotegory c if (a Stilde c_min) > Med and a Stilde C_Max <= Med.
        """
        actions = self.getActionsKeys()
        categories = self.orderedCategoryKeys()
        Med = self.valuationdomain['med']

        sorts = {}
        for c in categories:
            sorts[c] = set()
        for x in actions:
            if Comments:
                print(x)
            for c in categories:
                overMin=True
                overMax = True
                cMinKey= c+'-m'
                cMaxKey= c+'-M'
                if Comments:
                    print('\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey]))
                if self.relation[x][cMinKey] > Med:
                    overMin = True
                else:
                    break
                if self.relation[x][cMaxKey] <= Med:
                    overMax = False
                    #print '\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey])
                    sorts[c].add(x)
                    break
            if overMin and overMax:
                #print '\t %s: low = %.2f, high = %.2f' % (c,self.relation[x][cMinKey],self.relation[x][cMaxKey])
                sorts[c].add(x)
        if Comments:
            print('Sorting results')
            for c in self.orderedCategoryKeys():
                print('%s: %s' % (c, str(sorts[c])))
        return sorts

    def computeCategoryContents(self,Reverse=False,Comments=False):
        """
        Computes the sorting results per category.
        """
        actions = list(self.getActionsKeys())
        actions.sort()
        sorting = self.computeSortingCharacteristics(Comments=Comments)

        categoryContent = {}
        for c in self.orderedCategoryKeys(Reverse=Reverse):
            categoryContent[c] = []
            for x in actions:
                if sorting[x][c]['categoryMembership'] >= self.valuationdomain['med']:
                    categoryContent[c].append(x)
        return categoryContent
                                                     
    def showSorting(self,Reverse=True,isReturningHTML=False):
        """
        Shows sorting results in decreasing or increasing (Reverse=False)
        order of the categories. If isReturningHTML is True (default = False)
        the method returns a htlm table with the sorting result.
        """
        #from string import replace
        categoryContent = self.computeCategoryContents()
        try:
            lowerClosed = self.criteriaCategoryLimits['lowerClosed']
        except:
            lowerClosed = true
        if Reverse:
            print('\n*--- Sorting results in descending order ---*\n')
            prev_c = '>'
            if isReturningHTML:
                prev_c = '&gt;'
                html = '<h2>Sorting results in descending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
            for c in self.orderedCategoryKeys(Reverse=Reverse):
                if lowerClosed:
                    print(']%s - %s]:' % (prev_c,c), end=' ')
                    print('\t',categoryContent[c])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">]%s - %s]</td>' % (prev_c,c)
                        catString = str(categoryContent[c])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                else:
                    print('[%s - %s[:' % (prev_c,c), end=' ')
                    print('\t',categoryContent[c])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (prev_c,c)
                        catString = str(categoryContent[c])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                prev_c = c
        else:
            print('\n*--- Sorting results in ascending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in ascending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
            cat = [x for x in self.orderedCategoryKeys(Reverse=Reverse)]
            if isReturningHTML:
                cat.append('&lt;')
            else:
                cat.append('<')

            for i in range(len(cat)-1):
                if lowerClosed:
                    print('[%s - %s[:' % (cat[i],cat[i+1]), end=' ')
                    print('\t',categoryContent[cat[i]])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">]%s - %s]</td>' % (cat[i],cat[i+1])
                        catString = str(categoryContent[cat[i]])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
                else:
                    print(']%s - %s]:' % (cat[i],cat[i+1]), end=' ')
                    print('\t',categoryContent[cat[i]])
                    if isReturningHTML:
                        html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (cat[i],cat[i+1])
                        catString = str(categoryContent[cat[i]])
                        html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')

        if isReturningHTML:
            html += '</table>'
            return html

    def saveProfilesXMCDA2(self,fileName='temp',category='XMCDA 2.0 format',user='sortinDigraphs Module (RB)',version='saved from Python session',title='Sorting categories in XMCDA-2.0 format.',variant='Rubis',valuationType='bipolar',isStringIO=False,stringNA='NA',comment='produced by saveProfilesXMCDA2()'):
        """
        Save profiles object self in XMCDA 2.0 format.
        """
        import codecs
        if not isStringIO:
            print('*----- saving sorting profiles in XMCDA 2.0 format  -------------*')
        nameExt = fileName+'.xml'
        if isStringIO:
            comment='produced by stringIO()'
            import io
            ## ms = 100 * len(self.actions) + 500 * len(self.criteria) * 20 * len(self.evaluation)
            ## print 'estimated mapped memory size = %d' % (ms)
            ##fo = mmap.mmap(-1,ms)
            fo = io.StringIO()
        else:
            #nameExt = fileName+'.xmcda2'
            fo = codecs.open(nameExt,'w',encoding='utf-8')
        fo.write('<?xml version="1.0" encoding="UTF-8"?>\n')
        fo.write('<?xml-stylesheet type="text/xsl" href="xmcda2Rubis.xsl"?>\n')
        fo.write(str('<xmcda:XMCDA xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.decision-deck.org/2010/XMCDA-2.1.0-Rubis http://leopold-loewenheim.uni.lu/XMCDA2/XMCDA-2.1.0-Rubis.xsd" xmlns:xmcda="http://www.decision-deck.org/2010/XMCDA-2.1.0-Rubis" instanceID="void">\n'))

        # write description
        fo.write('<projectReference id="%s" name="%s">\n' % (fileName,nameExt))
        fo.write('<title>%s</title>\n' % (str(title)) )
        fo.write('<author>%s</author>\n' % (user) )
        fo.write('<version>%s</version>\n' % (version) )
        fo.write('<comment>%s</comment>\n' % (str(comment)) )
        fo.write('</projectReference>\n')


        #  save categories
        categoriesList = [x for x in self.categories]
        categoriesList.sort()
        na = len(categoriesList)
        categories = self.categories
        fo.write('<categories mcdaConcept="%s">\n' % ('categories'))
        fo.write('<description>\n')
        fo.write('<subTitle>Sorting categories.</subTitle>\n')
        fo.write('</description>\n')
        for i in range(na):
            try:
                categoryName = str(categories[categoriesList[i]]['name'])
            except:
                categoryName = categoriesList[i]
            fo.write('<category id="%s" name="%s" mcdaConcept="%s">\n' % (categoriesList[i],categoryName,'sortingCategory'))
            fo.write('<description>\n')
            fo.write('<comment>')
            try:
                fo.write(str(categories[categoriesList[i]]['comment']))
            except:
                fo.write('None')
            fo.write('</comment>\n')
            fo.write('</description>\n')
            fo.write('<type>real</type>\n')
            fo.write('<active>true</active>\n')
            fo.write('</category>\n')
        fo.write('</categories>\n')

        # save criteriaCategoryLimits
        criteriaList = [x for x in self.criteria]
        criteriaList.sort()
        categoriesList = [x for x in self.categories]
        categoriesList.sort()
        criteria = self.criteria
        fo.write('<criteriaCategoryLimits mcdaConcept="categoryProfiles">\n')
        fo.write('<description>\n')
        fo.write('<subTitle>Sorting profiles.</subTitle>\n')
        fo.write('</description>\n')
        for g in criteriaList:
            for c in categoriesList:
                try:
                    criterionName = str(criteria[g]['id'])
                except:
                    criterionName = g
                try:
                    categoryName = str(category[c]['id'])
                except:
                    categoryName = c

                fo.write('<criterionCategoryLimits id="lim_%s_%s" mcdaConcept="%s">\n' % (criterionName,categoryName,'criterionCategoryLimits' ) )
                fo.write('<description>\n')
                fo.write('<comment>%s</comment>\n' % ('No comment') )
                fo.write('<version>%s</version>\n' % ('Rubis k-sorting') )
                fo.write('</description>\n')
                fo.write('<criterionID>%s</criterionID>\n' % (criterionName) )
                fo.write('<categoryID>%s</categoryID>\n' % (categoryName) )
                fo.write('<lowLimit><real>%.2f</real></lowLimit>\n' % (self.criteriaCategoryLimits[g][c]['minimum']) )
                fo.write('<highLimit><real>%.2f</real></highLimit>\n' % (self.criteriaCategoryLimits[g][c]['maximum']) )

                fo.write('</criterionCategoryLimits>\n')
        fo.write('</criteriaCategoryLimits>\n')
        #########################
        fo.write('</xmcda:XMCDA>\n')
        if isStringIO:
            problemText = fo.getvalue()
            fo.close
            return problemText
        else:
            fo.close()
            print('File: ' + nameExt + ' saved !')

from weakOrders import WeakOrder
class QuantilesSortingDigraph(SortingDigraph,WeakOrder):
    """
    Specialisation of the sortingDigraph Class
    for sorting of alternatives into quantiles delimited ordered classes.
    
    .. note::

        We generally require an PerformanceTableau instance or a valid filename.
        If none is given, then a default profile with the limiting quartiles Q0,Q1,Q2, Q3 and Q4 is used on each criteria.
        By default lower closed limits of categories are supposed to be used in the sorting.

    Example Python3 session:

    >>> from sortingDigraphs import *
    >>> t = RandomCBPerformanceTableau(numberOfActions=7,numberOfCriteria=5,
    ...                                weightDistribution='equiobjectives')
    >>> qs = QuantilesSortingDigraph(t,limitingQuantiles=10)
    >>> qs.showSorting()
    *--- Sorting results in descending order ---*
    [0.90 - <[: 	 []
    [0.80 - 0.90[: 	 []
    [0.70 - 0.80[: 	 []
    [0.60 - 0.70[: 	 ['a02', 'a07']
    [0.50 - 0.60[: 	 ['a02', 'a04', 'a05', 'a06']
    [0.40 - 0.50[: 	 []
    [0.30 - 0.40[: 	 []
    [0.20 - 0.30[: 	 ['a03']
    [0.10 - 0.20[: 	 ['a01']
    [0.00 - 0.10[: 	 []
    >>> qs.exportGraphViz('quantilesSorting')
    
    .. image:: quantilesSorting.png
    """

    def __init__(self,argPerfTab=None,
                 limitingQuantiles=None,
                 LowerClosed=True,
                 PrefThresholds=True,
                 hasNoVeto=False,
                 minValuation=-1.0,
                 maxValuation=1.0,
                 outrankingType = "bipolar",
                 CompleteOutranking = True,
                 Threading=False,
                 Debug=False):
        """
        Constructor for QuantilesSortingDigraph instances.

        """

        from copy import deepcopy
        from decimal import Decimal

        # import the performance tableau
        if argPerfTab == None:
            perfTab = RandomPerformanceTableau(numberOfActions=10,
                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab
        # normalize the actions as a dictionary construct
        if isinstance(perfTab.actions,list):
            actions = {}
            for x in perfTab.actions:
                actions[x] = {'name': str(x)}
            self.actions = actions
        else:
            self.actions = deepcopy(perfTab.actions)

        # keep a copy of the original actions set before adding the profiles
        self.actionsOrig = deepcopy(self.actions)

        #  normalizing the performance tableau
        normPerfTab = NormalizedPerformanceTableau(perfTab)
        self.criteria = deepcopy(normPerfTab.criteria)
        self.convertWeightFloatToDecimal()
        self.evaluation = deepcopy(normPerfTab.evaluation)
        self.convertEvaluationFloatToDecimal()
        
        #  compute the limiting quantiles
        if isinstance(limitingQuantiles,list):
            self.name = 'sorting_with_given_quantiles'
            newLimitingQuantiles = []
            for x in limitingQuantiles:
                newLimitingQuantiles.append(Decimal(str(x)))
            limitingQuantiles = newLimitingQuantiles
            if Debug:
                print('convert to decimal!',limitingQuantiles)
        else:
            limitingQuantiles = self._computeQuantiles(limitingQuantiles,Debug=Debug)
        self.limitingQuantiles = deepcopy(limitingQuantiles)

        if Debug:
            print('limitingQuantiles',self.limitingQuantiles)

        # supposing all criteria scales between 0.0 and 100.0

        lowValue = 0.0
        highValue = 100.00
        # with preference direction = max
        categories = {}
        k = len(limitingQuantiles)-1
        if LowerClosed:
            for i in range(0,k-1):
                categories[str(i+1)] = {'name':'[%.2f - %.2f['\
                %(limitingQuantiles[i],limitingQuantiles[i+1]),\
                                'order':i+1,\
                                'lowLimit': '[%.2f' % (limitingQuantiles[i]),
                                'highLimit': '%.2f[' % (limitingQuantiles[i+1])}
            categories[str(k)] = {'name':'[%.2f - <['\
                %(limitingQuantiles[k-1]), 'order':k,\
                                  'lowLimit': '[%.2f' % (limitingQuantiles[k-1]),\
                                  'highLimit': '<['}                 
        else:
            categories[str(1)] = {'name':']< - %.2f]'\
                %(limitingQuantiles[1]), 'order':1,
                    'highLimit': '%.2f]' % (limitingQuantiles[1]),\
                    'lowLimit': ']<'}                                  
            for i in range(1,k):
                categories[str(i+1)] = {'name':']%.2f - %.2f]'\
                %(limitingQuantiles[i],limitingQuantiles[i+1]), 'order':i+1,
                        'lowLimit': ']%.2f' % (limitingQuantiles[i]),
                        'highLimit': '%.2f]' % (limitingQuantiles[i+1])}
        self.categories = deepcopy(categories)
        if Debug:
            print('categories',self.categories)

        criteriaCategoryLimits = {}
        criteriaCategoryLimits['lowerClosed'] = LowerClosed
        self.criteriaCategoryLimits = deepcopy(criteriaCategoryLimits)
        for g in self.criteria:
            gQuantiles = self._computeLimitingQuantiles(g,PrefThresholds=PrefThresholds,Debug=Debug)                
            criteriaCategoryLimits[g] = {}
            for c in categories:
                criteriaCategoryLimits[g][c]={
                    'minimum':gQuantiles[(int(c)-1)],
                    'maximum':gQuantiles[int(c)]
                    }
        self.criteriaCategoryLimits = deepcopy(criteriaCategoryLimits)
        if Debug:
            print('CriteriaCategoryLimits',self.criteriaCategoryLimits)

        # set the category limits type (lowerClosed = True is default)
        # self.criteriaCategoryLimits['lowerClosed'] = LowerClosed
        # print 'lowerClosed', lowerClosed

        # add the catogory limits to the actions set
        self.profiles = {'min':{},'max':{}}
        self.profileLimits = set()
        for c in list(self.categories.keys()):
            cMinKey = c+'-m'
            cMaxKey = c+'-M'
            self.profileLimits.add(cMinKey)
            self.profileLimits.add(cMaxKey)
            self.actions[cMinKey] = {'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.actions[cMaxKey] = {'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            self.profiles['min'][cMinKey] = {'category': c, 'name': 'categorical low limits', 'comment': 'Inferior or equal limits for category membership assessment'}
            self.profiles['max'][cMaxKey] = {'category': c, 'name': 'categorical high limits', 'comment': 'Lower or equal limits for category membership assessment'}
            for g in list(self.criteria.keys()):
                try:
                    if self.criteria[g]['preferenceDirection'] == 'max':
                        self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                        self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))
                    elif self.criteria[g]['preferenceDirection'] == 'min':
                        if not defaultProfiles:
                            highValueg = Decimal(str(self.criteria[g]['scale'][1]))
                        else:
                            highValueg = Decimal(str(highValue))
                        #print 'highValue = ', highValue
                        self.evaluation[g][cMinKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['minimum'])))
                        self.evaluation[g][cMaxKey] = -(highValueg - Decimal(str(self.criteriaCategoryLimits[g][c]['maximum'])))
                    else:
                        print('===>>>>> Error')
                except:

                    self.evaluation[g][cMinKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['minimum']))
                    self.evaluation[g][cMaxKey] = Decimal(str(self.criteriaCategoryLimits[g][c]['maximum']))

        if Debug:
            print('Profiles',self.profiles)
            print('ProfileLimits',self.profileLimits)
            
        self.convertEvaluationFloatToDecimal()

        # construct outranking relation
        self.hasNoVeto = hasNoVeto
        if outrankingType == "robust":
            g = RobustOutrankingDigraph(self)
            self.valuationdomain = deepcopy(g.valuationdomain)
            self.relation = deepcopy(g.relation)
        elif outrankingType == "likely":
            g = StochasticBipolarOutrankingDigraph(self,
                                                   sampleSize = 50,
                                                   samplingSeed = None,
                                                   hasNoVeto = hasNoVeto,
                                                   Debug = Debug,
                                                   spread = 1.0,
                                                   likelihood = 0.9,
                                                   distribution = 'triangular')
            self.valuationdomain = deepcopy(g.valuationdomain)
            self.relation = deepcopy(g.relation)
            
        else:
            if CompleteOutranking:
                g = BipolarOutrankingDigraph(normPerfTab,hasNoVeto=hasNoVeto)
                g.recodeValuation(minValuation,maxValuation)
                self.relationOrig = deepcopy(g.relation)
                Min = g.valuationdomain['min']
                Max = g.valuationdomain['max']
            else:
                Min = Decimal(str(minValuation))
                Max = Decimal(str(maxValuation))
            Med = (Max + Min)/Decimal('2.0')
            self.valuationdomain = {'min': Min, 'med':Med ,'max':Max }
            if LowerClosed:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       initial=self.actionsOrig,
                                                       terminal=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                       hasBipolarVeto=True,
                                                        Threading=Threading)
            else:
                self.relation = self._constructRelation(self.criteria,
                                                       self.evaluation,
                                                       terminal=self.actionsOrig,
                                                       initial=self.profileLimits,
                                                       hasNoVeto=hasNoVeto,
                                                        hasBipolarVeto=True,
                                                        Threading=Threading)
            if LowerClosed:
                for x in self.actionsOrig:
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for x in self.profileLimits:
                    self.relation[x] = {}
                    for y in self.actions:
                        self.relation[x][y] = Med
            else:
                for x in self.actionsOrig:
                    self.relation[x] = {}
                    for y in self.actionsOrig:
                        self.relation[x][y] = Med
                for y in self.profileLimits:
                    for x in self.actions:
                        self.relation[x][y] = Med

        # compute weak ordering
        sortingRelation = self.computeSortingRelation(Debug=Debug)
        for x in self.actionsOrig:
            for y in self.actionsOrig:
                self.relation[x][y] = sortingRelation[x][y]

        # reset original action set
        self.actions = self.actionsOrig
        self.order = len(self.actions)

        # compute weak ordering by choosing
        
##        if self.order < 20:
##            self.computeRankingByChoosing(CoDual=True)
        
        # init general digraph Data
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

    def showWeakOrder(self,Descending=True):
        """
        Specialisation for QauntilesSortingDigraphs.
        """
        from decimal import Decimal
        cC = self.computeCategoryContents()
        
        if Descending:
            cCKeys = self.orderedCategoryKeys(Reverse = True)
        else:
            cCKeys = self.orderedCategoryKeys(Reverse = False)
        n = len(cC)
        n2 = n//2
        ordering = []
        
        for i in range(n2):
            if i == 0:
                x = cC[cCKeys[i]]
                y = cC[cCKeys[n-i-1]]
                setx = set(x)
                sety = set(y) - setx
            else:
                x = list(set(cC[cCKeys[i]]) - (setx | sety))
                setx = setx | set(x)
                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
                sety = sety | set(y)
            if x != [] or y != []:
                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
        if 2*n2 < n:
            if n2 == 0:
                x = cC[cCKeys[n2]]
            else:
                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),x) ) )

##        orderingList = []
##        for i in range(n2):
##            x = ordering[i][0][1]
##            if x != []:
##                orderingList.append(x)
##        if 2*n2 < n:
##            x = ordering[i][0][1]
##            y = ordering[i][1][1]
##            if x != []:
##                orderingList.append(x)
##            if y != []:
##                orderingList.append(y)
##        for i in range(n2):
##            y = ordering[n2-i-1][1][1]
##            if y != []:
##                orderingList.append(y)
##            
        
        weakOrdering = {'result':ordering}

        WeakOrder.showWeakOrder(self,weakOrdering)

##        return orderingList

##    def computeWeakOrder(self,Descending=True):
##        """
##        Specialisation for QauntilesSortingDigraphs.
##        """
##        from decimal import Decimal
##        cC = self.computeCategoryContents()
##        
##        if Descending:
##            cCKeys = self.orderedCategoryKeys(Reverse = True)
##        else:
##            cCKeys = self.orderedCategoryKeys(Reverse = False)
##        n = len(cC)
##        n2 = n//2
##        ordering = []
##        
##        for i in range(n2):
##            if i == 0:
##                x = cC[cCKeys[i]]
##                y = cC[cCKeys[n-i-1]]
##                setx = set(x)
##                sety = set(y) - setx
##            else:
##                x = list(set(cC[cCKeys[i]]) - (setx | sety))
##                setx = setx | set(x)
##                y = list(set(cC[cCKeys[n-i-1]]) - (setx | sety))
##                sety = sety | set(y)
##            if x != [] or y != []:
##                ordering.append( ( (Decimal(str(i+1)),x),(Decimal(str(n-i)),y) ) )
##        if 2*n2 < n:
##            if n2 == 0:
##                x = cC[cCKeys[n2]]
##            else:
##                x = list(set(cC[cCKeys[n2]]) - (setx | sety))
##            ordering.append( ( (Decimal(str(n2+1)),x),(Decimal(str(n2+1)),x) ) )
##
##        #print(ordering)
##        
##        orderingList = []
##        n = len(ordering)
##        for i in range(n):
##            x = ordering[i][0][1]
##            if x != []:
##                orderingList.append(x)
##        for i in range(n):
##            y = ordering[n-i-1][1][1]
##            if y != []:
##                orderingList.append(y)
####            
####        
####        weakOrdering = {'result':ordering}
####
####        WeakOrder.showWeakOrder(self,weakOrdering)
##
##        return orderingList
##
##    def showOrderedRelationTable(self,direction="decreasing"):
##        """
##        Showing the relation table in decreasing (default) or increasing order.
##        """
##        if direction == "decreasing":
##            Descending = True
##        else:
##            Descending = False
##
##        weakOrdering = self.computeWeakOrder(Descending)
##        
##        actionsList = []
##        for eq in weakOrdering:
##            #print(eq)
##            eq.sort()
##            for x in eq:
##                actionsList.append(x)
##        if len(actionsList) != len(self.actions):
##            print('Error !: missing action(s) %s in ordered table.')
##            
##        Digraph.showRelationTable(self,actionsSubset=actionsList,\
##                                relation=self.relation,\
##                                Sorted=False,\
##                                ReflexiveTerms=False)
        

    def _computeQuantiles(self,x,Debug=True):
        """
        renders the limiting quantiles
        """
        from math import floor
        if isinstance(x,int):
            n = x
        elif x == None:
            n = 4
        elif x == 'bitiles':
            n = 2
        elif x == 'tritiles':
            n = 3
        elif x == 'quartiles':
            n = 4
        elif x == 'quintiles':
            n = 5
        elif x == 'sextiles':
            n = 6
        elif x == 'septiles':
            n = 7
        elif x == 'octiles':
            n = 8
        elif x == 'deciles':
            n = 10
        elif x == 'dodeciles':
            n = 20
        elif x == 'centiles':
            n = 100
        elif x == 'automatic':
            pth = [5]
            for g in self.criteria:
                try:
                    pref = self.criteria[g]['thresholds']['ind'][0] + \
                           (self.criteria[g]['thresholds']['ind'][1]*Decimal('100'))
                    pth.append(pref)
                except:
                    pass
            amp = max(Decimal('1'),min(pth))
            n = int(floor(Decimal('100')/amp))
            if Debug:
                print('Detected preference thresholds = ',pth)
                print('amplitude, n',amp,n)

        limitingQuantiles = []
        for i in range(n+1):
            limitingQuantiles.append( Decimal(str(i)) / Decimal(str(n)) )
        self.name = 'sorting_with_%d-tile_limits' % n
        return limitingQuantiles
                                         
    def _computeLimitingQuantiles(self,g,Debug=True,PrefThresholds=True):
        """
        Renders the list of limiting quantiles on criteria g
        """
        from math import floor
        from copy import deepcopy
        gValues = []
        for x in self.actionsOrig:
            if Debug:
                print('g,x,evaluation[g][x]',g,x,self.evaluation[g][x])
            if self.evaluation[g][x] != Decimal('-999'):
                gValues.append(self.evaluation[g][x])
        gValues.sort()
        if PrefThresholds:
            try:
                gPrefThrCst = self.criteria[g]['thresholds']['pref'][0]
                gPrefThrSlope = self.criteria[g]['thresholds']['pref'][1]
            except:
                gPrefThrCst = Decimal('0')
                gPrefThrSlope = Decimal('0')            
        n = len(gValues)
        if Debug:
            print('g,n,gValues',g,n,gValues)
        nf = Decimal(str(n+1))
        limitingQuantiles = deepcopy(self.limitingQuantiles)
        limitingQuantiles.sort()
        if Debug:
            print(limitingQuantiles)
        LowerClosed = self.criteriaCategoryLimits['lowerClosed']
        if LowerClosed:
            limitingQuantiles = limitingQuantiles[:-1]
        else:
            limitingQuantiles = limitingQuantiles[1:]
        if Debug:
            print(limitingQuantiles)
        # computing the quantiles on criterion g
        gQuantiles = []
        if LowerClosed:
            # we ignore the 1.00 quantile and replace it with +infty
            for q in self.limitingQuantiles:
                r = (nf * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq < (n-1):
                    quantile = gValues[rq] + ((r-rq)*(gValues[rq+1]-gValues[rq]))
                    if rq > 0 and PrefThresholds:
                        quantile += gPrefThrCst + quantile*gPrefThrSlope
                else :
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('100.0')
                    else:
                        quantile = Decimal('200.0')
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)               

        else:  # upper closed categories
            # we ignore the quantile 0.0 and replace it with -\infty            
            for q in self.limitingQuantiles:
                r = (nf * q)
                rq = int(floor(r))
                if Debug:
                    print('r,rq',r,rq, end=' ')
                if rq == 0:
                    if self.criteria[g]['preferenceDirection'] == 'min':
                        quantile = Decimal('-200.0')
                    else:
                        quantile = Decimal('-100.0')
                elif rq < (n-1):
                    quantile = gValues[rq]\
                               + ((r-rq)*(gValues[rq+1]-gValues[rq]))
                    if PrefThresholds:
                        quantile -= gPrefThrCst - quantile*gPrefThrSlope
                else:
                    quantile = gValues[n-1]
                if Debug:
                    print('quantile',quantile)
                gQuantiles.append(quantile)
        if Debug:
            print(g,LowerClosed,self.criteria[g]['preferenceDirection'],gQuantiles)
        return gQuantiles
                
    def showSorting(self,Reverse=True,isReturningHTML=False,Debug=False):
        """
        Shows sorting results in decreasing or increasing (Reverse=False)
        order of the categories. If isReturningHTML is True (default = False)
        the method returns a htlm table with the sorting result.
        
        """
        #from string import replace
        from copy import deepcopy
        categoryContent = self.computeCategoryContents()
        categoryKeys = self.orderedCategoryKeys(Reverse=Reverse)
        try:
            lowerClosed = self.criteriaCategoryLimits['lowerClosed']
        except:
            lowerClosed = True
        if Reverse:
            print('\n*--- Sorting results in descending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in descending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
        else:
            print('\n*--- Sorting results in ascending order ---*\n')
            if isReturningHTML:
                html = '<h2>Sorting results in ascending order</h2>'
                html += '<table style="background-color:White;" border="1"><tr bgcolor="#9acd32"><th>Categories</th><th>Assorting</th></tr>'
##        if lowerClosed:
##            #print('Lower closed categories')
##        else:
##            #print('Upper closed categories')
        for c in categoryKeys:
            print('%s:' % (self.categories[c]['name']), end=' ')
            print('\t',categoryContent[c])
            if isReturningHTML:
                #html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (limprevc,limc)
                html += '<tr><td bgcolor="#FFF79B">%</td>' % (self.categories[c]['name'])
                catString = str(categoryContent[c])
                html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')
##            if lowerClosed:
##                print('Lower closed categories')
##            else:
##                print('Upper closed categories')
##            for c in categoryKeys:
##                print('%s:' % (self.categories[c]['name']), end=' ')
##                print('\t',categoryContent[c])
##                if isReturningHTML:
##                    #html += '<tr><td bgcolor="#FFF79B">[%s - %s[</td>' % (limprevc,limc)
##                    html += '<tr><td bgcolor="#FFF79B">%</td>' % (self.categories[c]['name'])
##                    catString = str(categoryContent[c])
##                    html += '<td>%s</td></tr>' % catString.replace('\'','&apos;')

        if isReturningHTML:
            html += '</table>'
            return html

    def computeSortingRelation(self,categoryContents=None,Debug=False):
        """
        constructs a bipolar sorting relation using the category contents.
        """
        if categoryContents == None:
            categoryContents = self.computeCategoryContents()
        categoryKeys = self.orderedCategoryKeys()
        Max = self.valuationdomain['max']
        Med = self.valuationdomain['med']
        Min = self.valuationdomain['min']
        actions = [x for x in self.actionsOrig]
        currActions = set(actions)
        sortingRelation = {}
        for x in actions:
            sortingRelation[x] = {}
            for y in actions:
                sortingRelation[x][y] = Med
                
        if Debug:
            print('categoryContents',categoryContents)
        for i in categoryKeys:
            ibch = set(categoryContents[i])
            ribch = set(currActions) - ibch
            if Debug:
                print('ibch,ribch',ibch,ribch)
            for x in ibch:
                for y in ibch:
                    sortingRelation[x][y] = Med
                    sortingRelation[y][x] = Med
                for y in ribch:
                    sortingRelation[x][y] = Min
                    sortingRelation[y][x] = Max
            currActions = currActions - ibch
        return sortingRelation

    def showActionCategories(self,action,Debug=False,Comments=True):
        """
        Renders the union of categories in which the given action is sorted positively or null into.
        Returns a tuple : action, lowest category key, highest category key, membership credibility !
        """
        Med = self.valuationdomain['med']
        sorting = self.computeSortingCharacteristics(action=action,Comments=Debug)
        keys = []
        for c in self.orderedCategoryKeys():
            if sorting[action][c]['categoryMembership'] >= Med:
                if sorting[action][c]['lowLimit'] > Med:
                    lowLimit = sorting[action][c]['lowLimit']
                if sorting[action][c]['notHighLimit'] > Med:
                    notHighLimit = sorting[action][c]['notHighLimit']
                keys.append(c)
                if Debug:
                    print(action, c, sorting[action][c])
        n = len(keys)
        credibility = min(lowLimit,notHighLimit)
        if n == 0:
            return None
        elif n == 1:
            if Comments:
                print('%s in %s - %s with credibility: %.2f' % (action,\
                                     self.categories[keys[0]]['lowLimit'],\
                                     self.categories[keys[0]]['highLimit'],\
                                     credibility) )
            return action,\
                    keys[0],\
                    keys[0],\
                    credibility
        else:
            if Comments:
                print('%s in %s - %s with credibility: %.2f' % (action,\
                                     self.categories[keys[0]]['lowLimit'],\
                                     self.categories[keys[-1]]['highLimit'],\
                                     credibility) )
            return action,\
                    keys[0],\
                    keys[-1],\
                    credibility            

    def showActionsSortingResult(self,actionSubset=None):
        """
        shows the quantiles sorting result all (default) of a subset of the decision actions.
        """
        if actionSubset == None:
            actions = [x for x in self.actions]
        else:
            actions = [x for x in actionSubset]
        actions.sort()
        print('Quantiles sorting result per decision action')
        for x in actions:
            self.showActionCategories(x)
            

class _OptimalHarmonicQuantilesSortingDigraph(QuantilesSortingDigraph):
    """
    Specialisation of the QuantilesSortingDigraph Class
    for optimal sorting of alternatives into
    quantiles delimited ordered classes. 
    """
    def __init__(self,argPerfTab=None,
                 minQuantiles=4,
                 maxQuantiles=200,
                 LowerClosed=True,
                 PrefThresholds=True,
                 hasNoVeto=False,
                 minValuation=-100.0,
                 maxValuation=100.0,
                 outrankingType = "bipolar",
                 Prudent=False,
                 Threading=False,
                 Debug=False):
        
        from copy import deepcopy
        if argPerfTab != None:
            t = argPerfTab
        else:
            t = RandomCBPerformanceTableau()
        g = BipolarOutrankingDigraph(t)
        maxCorr = {'correlation': Decimal('-1.0')}
        maxCorr['determination'] = Decimal('0.0')
        qs = None
        nbrActions = len(t.actions)
        nq = nbrActions+1
        divNbrActions = []
        for i in range(minQuantiles,nq):
            if (nbrActions%i) == 0:
                divNbrActions.append(i)
        if Debug:
            print(divNbrActions)
        testNQ = [(i+1) for i in divNbrActions]
        for m in range(2,10):
            if m*(nbrActions+1) < maxQuantiles:
                testNQ.append(m*(nbrActions+1))
        if Debug:
            print(testNQ)
        for nq in testNQ:
            if Debug:
                print( '%d-tiling' % (nq) )
            qs0 = QuantilesSortingDigraph(t,limitingQuantiles=nq,Threading=False)
            qs0Corr = g.computeOrdinalCorrelation(qs0)
            if Debug:
                print( 'correlation0 = %.3f' % qs0Corr['correlation'] )
            if Prudent:
                if qs0Corr['correlation'] > maxCorr['correlation']:
                    maxCorr = deepcopy(qs0Corr)
                    maxqs = deepcopy(qs0)                
            else:
                if qs0Corr['correlation']*qs0Corr['determination'] > maxCorr['correlation']*maxCorr['determination']:
                    maxCorr = deepcopy(qs0Corr)
                    maxqs = deepcopy(qs0)
            
        self.name = deepcopy(maxqs.name)
        self.actions = deepcopy(maxqs.actions)
        self.actionsOrig = deepcopy(maxqs.actionsOrig)
        self.order = len(self.actions)
        self.criteria = deepcopy(maxqs.criteria)
        self.evaluation = deepcopy(maxqs.evaluation)
        self.profiles = deepcopy(maxqs.profiles)
        self.valuationdomain = deepcopy(maxqs.valuationdomain)
        self.relation = deepcopy(maxqs.relation)
        self.categories = deepcopy(maxqs.categories)
        self.criteriaCategoryLimits = deepcopy(maxqs.criteriaCategoryLimits)
        self.limitingQuantiles = deepcopy(maxqs.limitingQuantiles)
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

class OptimalQuantilesSortingDigraph(QuantilesSortingDigraph):
    """
    Specialisation of the QuantilesSortingDigraph Class
    for optimal sorting of alternatives into
    quantiles delimited ordered classes. 
    """
    def __init__(self,argPerfTab=None,
                 minQuantiles=4,
                 maxQuantiles=50,
                 LowerClosed=True,
                 PrefThresholds=True,
                 hasNoVeto=False,
                 minValuation=-100.0,
                 maxValuation=100.0,
                 outrankingType = "bipolar",
                 Prudent=False,
                 Threading=False,
                 Debug=False):
        
        from copy import deepcopy
        if argPerfTab != None:
            t = argPerfTab
        else:
            t = RandomCBPerformanceTableau()
        g = BipolarOutrankingDigraph(t)
        maxCorr = {'correlation': Decimal('-1.0')}
        maxCorr['determination'] = Decimal('0.0')
        maxqs = None
        maxnq = 20
        if Debug:
            fo = open('debug.csv','w')
            fo.write('"nqs","qsopt","qscorr","qsdeter"\n')
        for nq in range(minQuantiles,maxQuantiles):
            #print( '%d-tiling' % (nq) )
            qs0 = QuantilesSortingDigraph(t,limitingQuantiles=nq,
                                         LowerClosed=True,
                                         PrefThresholds=True,
                                         hasNoVeto=False,
                                         minValuation=-1.0,
                                         maxValuation=1.0,
                                         outrankingType = "bipolar",
                                        Threading=False)
            qs0Corr = g.computeOrdinalCorrelation(qs0)
            if Debug:
                fo.write('%d,%.6f,%.6f,%.6f\n' % (nq,qs0Corr['correlation']*qs0Corr['determination'],
                                              qs0Corr['correlation'],qs0Corr['determination']))
                print( '%d,%.6f,%.6f,%.6f\n' % (nq,qs0Corr['correlation']*qs0Corr['determination'],
                                              qs0Corr['correlation'],qs0Corr['determination']))
            if Prudent:
                if qs0Corr['correlation'] > maxCorr['correlation']:
                    maxCorr = deepcopy(qs0Corr)
                    maxqs = deepcopy(qs0)                
            else:
                if qs0Corr['correlation']*qs0Corr['determination'] >\
                                    maxCorr['correlation']*maxCorr['determination']:
                    maxCorr = deepcopy(qs0Corr)
                    maxqs = deepcopy(qs0)
        if Debug:
            fo.close()
            
        self.name = deepcopy(maxqs.name)
        self.actions = deepcopy(maxqs.actions)
        self.actionsOrig = deepcopy(maxqs.actionsOrig)
        self.order = len(self.actions)
        self.criteria = deepcopy(maxqs.criteria)
        self.evaluation = deepcopy(maxqs.evaluation)
        self.profiles = deepcopy(maxqs.profiles)
        self.valuationdomain = deepcopy(maxqs.valuationdomain)
        self.relation = deepcopy(maxqs.relation)
        self.categories = deepcopy(maxqs.categories)
        self.criteriaCategoryLimits = deepcopy(maxqs.criteriaCategoryLimits)
        self.limitingQuantiles = deepcopy(maxqs.limitingQuantiles)
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

##############################
## from weakOrders import WeakOrder
def _quantilesRankingTask(categID):
    """
    Task definition for multiprocessing threaded jobs in QsRbcRanking.
    
    .. note::
    
          Parameter maxContent: maximum allowed local catContent for rbc
          is set to 50. Above this cardinality,
          Tideman's ranked pairs heuristics is used.
    """
    from tempfile import TemporaryDirectory
    from os import getcwd, chdir
    from pickle import dumps, loads, load
    from copy import deepcopy
    from outrankingDigraphs import BipolarOutrankingDigraph
    #from linearOrders import RankedPairsOrder, KohlerOrder
    from weakOrders import PrincipalInOutDegreesOrdering
    maxCatContent = 40
    print("Starting working on category %d" % (categID), end=" ")
    fiName = 'partialPerfTab-'+str(categID)+'.py'
    fi = open(fiName,'rb')
    pt = loads(fi.read())
    fi.close()
    with TemporaryDirectory() as TempDirName:
        cwd = getcwd()
        chdir(TempDirName)
        digraph = BipolarOutrankingDigraph(pt,Normalized=True)
        Max = digraph.valuationdomain['max']
        Med = digraph.valuationdomain['med']
        catContent = [x for x in digraph.actions]
        nc = len(catContent)
        print(nc,maxCatContent)
        #print(catContent)
        if nc <= maxCatContent:
            currActions = list(catContent)
            try:
                catCRbc = digraph.computeRankingByChoosing()
            except:
                print('==>>> Failed RBC: Principal ranking')
##              rp = RankedPairsOrder(digraph)
##              catRbc = rp.computeRankingByChoosing()
##                ko = KohlerOrder(digraph)
##                catCRbc = ko.computeRankingByChoosing()
                try:
                    pri = PrincipalInOutDegreesOrdering(digraph,Threading=False)
                    catCRbc = pri.computeWeakOrder()
                except:
                    catCRbc = {'result': \
                               [((digraph.valuationdomain['max'],catContent),\
                                (digraph.valuationdomain['max'],catContent))]}
        else:
            print('==>>> Exceeds %d: Principal ranking' % maxCatContent)
##            rp = RankedPairsOrder(digraph)
##            catCRbc = rp.computeRankingByChoosing()
##            ko = KohlerOrder(digraph)
##            catCRbc = ko.computeRankingByChoosing()
            try:
                pri = PrincipalInOutDegreesOrdering(digraph,Threading=False)
                catCRbc = pri.computeWeakOrder()
            except:
                catCRbc = {'result': [((digraph.valuationdomain['max'],catContent),\
                                       (digraph.valuationdomain['max'],catContent))]}

        catRbc = deepcopy(catCRbc['result'])
        currActions = list(catContent)
        catRelation = digraph.computeRankingByChoosingRelation(\
                            actionsSubset=currActions,\
                            rankingByChoosing=catRbc,\
                            Debug=False)
        
        #print(catRbc,catRelation)
        splitCatRelation = [catRbc,catRelation]
        chdir(cwd)
    foName = 'splitCatRelation-'+str(categID)+'.py'
    fo = open(foName,'wb')                                            
    fo.write(dumps(splitCatRelation,-1))
    fo.close()
    writestr = 'Finished category %d %d' % (categID,nc)
    return writestr
#####

class QuantilesRankingDigraph(QuantilesSortingDigraph):
    """
    Refinig a quantiles sorting result
    with a ranking-by-choosing of the local quantile equivalence classes
    of less than 50 items.
    For larger quantile equivalence classes, Tideman's ranked pairs heuristic
    is used insted.

    *Parameter*:
          * limitingQuantiles are set by default to len(actions)//2
            for outranking digraph orders below 200.
            For higher orders, centiles are used by default.

          * threading is on by default for cpu with more than 2 cores.

    .. note::

          The weakording is instantiated as strict ordering! And for larger orders
          a consistent size of several Giga bytes cpu memory is required.
          
    """

    def __init__(self,
                 argPerfTab=None,
                 limitingQuantiles=None,
                 LowerClosed=True,
                 PrefThresholds=True,
                 hasNoVeto=False,
                 minValuation=-1.0,
                 maxValuation=1.0,
                 outrankingType = "bipolar",
                 Descending=True,
                 Threading=True,
                 cores=None,
                 Comments=True,
                 Debug=False):
        
        from copy import deepcopy
        from sortingDigraphs import QuantilesSortingDigraph
        from multiprocessing import Pool, cpu_count
        from time import time

        # import the performance tableau
        if argPerfTab == None:
            perfTab = RandomPerformanceTableau(numberOfActions=10,
                                               numberOfCriteria=13)
        else:
            perfTab = argPerfTab

        na = len(perfTab.actions)

        if limitingQuantiles == None:
            if na < 200:
                limitingQuantiles = na // 2
            else:
                limitingQuantiles = 100
        if Comments:        
            print('Computing the %d-quantiles sorting digraph ...' % (limitingQuantiles))
        t0 = time()
        if Threading and cpu_count() > 2:    
            qs = QuantilesSortingDigraph(perfTab,
                         limitingQuantiles=limitingQuantiles,
                         LowerClosed=LowerClosed,
                         PrefThresholds=PrefThresholds,
                         hasNoVeto=hasNoVeto,
                         minValuation=minValuation,
                         maxValuation=maxValuation,
                         outrankingType = outrankingType,
                         Threading=True,
                         CompleteOutranking = False)                
        else:
            qs = QuantilesSortingDigraph(perfTab,
                         limitingQuantiles=limitingQuantiles,
                         LowerClosed=LowerClosed,
                         PrefThresholds=PrefThresholds,
                         hasNoVeto=hasNoVeto,
                         minValuation=minValuation,
                         maxValuation=maxValuation,
                         outrankingType = outrankingType,
                         CompleteOutranking = True)
        self.tqs = time() - t0
        if Comments:
            print('execution time: %.4f' % (self.tqs))
        
        Max = qs.valuationdomain['max']
        Med = qs.valuationdomain['med']
        catContent = {}
##        weakOrdering = qs.computeWeakOrder()
##        nwo = len(weakOrdering)
##        for i in range(nwo):
##            catContent[i+1] = weakOrdering[i]
##            if Debug:
##                print(i+1,weakOrdering[i])        
        weakOrdering = qs.computeWeakOrder(Debug=Debug)
        nwo = len(weakOrdering)
        for i in range(nwo):
            catContent[i+1] = weakOrdering[i]
            if Debug:
                print(i+1,weakOrdering[i])        

        qsRelation = deepcopy(qs.relation)

        catRelation = {}
        catRbc = {}
        if Threading and cpu_count() > 2:
            from pickle import dumps, loads, load
            if cores == None:
                cores = 8
            Nproc = cpu_count()
            if Nproc > cores:
                Nproc = cores
            from tempfile import TemporaryDirectory
            from os import getcwd, chdir
            with TemporaryDirectory() as tempDirName:
                cwd = getcwd()
                chdir(tempDirName)
                filledCategKeys = []
                print('Preparing the thread data ...')
                t0 = time()
                for c in range(1,nwo+1):
                    nc = len(catContent[c])
                    if Debug:
                        print('%d/%d %d' %(c,nwo,nc))
                    if nc > 1:
                        filledCategKeys.append(int(c))
                        pt = PartialPerformanceTableau(perfTab,actionsSubset=catContent[c])                     
                        foName = 'partialPerfTab-'+str(c)+'.py'
                        fo = open(foName,'wb')
                        ptDp = dumps(pt,-1)
                        fo.write(ptDp)
                        fo.close()
                t1 = time()
                if Comments:
                    print(filledCategKeys)
                    print('%d of %d' % (len(filledCategKeys),nwo))
                    print('Execution time: %.4f sec.' % (t1-t0))
                
                print('Threading ... !')
                t0 = time()
                with Pool(processes=Nproc) as pool:
                    for res in pool.imap_unordered(_quantilesRankingTask,filledCategKeys):
                        print(res)
                self.trbc = time() - t0
                print('Finished all threads in %.4f sec.' % (self.trbc) )
                for c in range(1,nwo+1):                    
                    nc = len(catContent[c])
                    if nc > 1:
                        fiName = 'splitCatRelation-'+str(c)+'.py'
                        fi = open(fiName,'rb')
                        splitCatRelation = loads(fi.read())
                        fi.close()
                        if Debug:
                            print(c,'catRbc',splitCatRelation[0])
                            print(c,'catRelation',splitCatRelation[1])
                        catRbc[c] = splitCatRelation[0]
                        catRelation[c] = splitCatRelation[1]
                    elif nc == 1:
                        if Debug:
                            print('singleton category %d : %d' % (c,nc))
                            print(catContent[c])
                        catRbc[c] = [((Max,catContent[c]),(Max,catContent[c]))]
                        for x in catContent[c]:
                            catRelation[c] = {str(x): {str(x): Med}}
                        if Debug:
                            print(c,'catRbc',catRbc[c])
                            print(c,'catRelation',catRelation[c])               
                chdir(cwd)                
        else:
            ## without threading
            if Comments:
                print('Without threading ...')
            for c in range(1,nwo+1):
                if Debug:
                    print(c, len(catContent[c]))
                if len(catContent[c]) > 0:
                    currActions = list(catContent[c])
                    for x in currActions:
                        for y in currActions:
                            qs.relation[x][y] = qs.relationOrig[x][y]
                    catCRbc = qs.computeRankingByChoosing(currActions)
                    if Debug:
                        print(c,catCRbc)
                    catRbc[c] = deepcopy(catCRbc['result'])
                    currActions = list(catContent[c])
                    catRelation[c] = qs.computeRankingByChoosingRelation(\
                        actionsSubset=currActions,\
                        rankingByChoosing=catCRbc['result'],\
                        Debug=False)

        self.name = 'qsrbc-'+qs.name
        self.actions = deepcopy(qs.actions)
        self.order = len(self.actions)
        self.criteria = deepcopy(qs.criteria)
        self.evaluation = deepcopy(qs.evaluation)
        self.categories = deepcopy(qs.categories)
        self.criteriaCategoryLimits = deepcopy(qs.criteriaCategoryLimits)
        self.profiles = deepcopy(qs.profiles)
        self.valuationdomain = deepcopy(qs.valuationdomain)
        self.catRbc = deepcopy(catRbc)
        try:
            self.relationOrig = deepcopy(qs.relationOrig)
        except:
            pass
        self.preOrdering = self.computeQsRbcRanking(Descending=Descending,Debug=False)
        self.qsRelation = deepcopy(qsRelation)
        self._constructRelation(Descending=Descending)
        self.gamma = self.gammaSets()
        self.notGamma = self.notGammaSets()

    def _constructRelation(self,Descending=True):
        """
        Instantiates the weak order by taking the codual of the
        preoder obtained from the quantiles ranking !
        """
        from copy import deepcopy
        relation = deepcopy(self.computePreorderRelation(self.preOrdering))
        actionsList = [x for x in self.actions]
        Max = self.valuationdomain['max']
        Min = self.valuationdomain['min']
        self.relation = {}
        for x in actionsList:
            self.relation[x] = {}
            for y in actionsList:
##                self.relation[x][y] = relation[x][y]
                self.relation[x][y] = Max - relation[y][x] + Min

    def computeWeakOrder(self,Descending=True,Comments=False,Debug=False):
        """
        specialisation of the SortingDigraph.WeakOrder method
        """
        if Comments:
            Debug=True
        actionsCategories = {}
        for x in self.actions:
            a,lowCateg,highCateg,credibility =\
                     self.showActionCategories(x,Comments=Debug)
            try:
                actionsCategories[(int(highCateg),int(lowCateg))].append(a)
            except:
                actionsCategories[(int(highCateg),int(lowCateg))] = [a]
        actionsCategIntervals = []
        for interval in actionsCategories:
            actionsCategIntervals.append([interval, actionsCategories[interval]])
        actionsCategIntervals.sort(reverse=Descending)
        weakOrdering = []
        for item in actionsCategIntervals:
            if Debug:
                print(item)
            weakOrdering.append(item[1])
        return weakOrdering

    def computeQsRbcRanking(self,Descending=True,
                            Comments=False,
                            Debug=False):
        """                                                                     
        Render the ranking result of QsRbcWeakOrdering constructor                              
        """
        if Debug:
            Comments=True
        rbcResult = [(i,self.catRbc[i]) for i in self.catRbc]
        rbcResult.sort()
        ranking = []
        remainingActions = set([x for x in self.actions])
        for it in rbcResult:
            ordering = it[1]
            n = len(ordering)
            if Debug:
                print(ordering,n)
            for i in range(n):
                ranking.append(ordering[i][0][1])
                remainingActions = remainingActions - set(ordering[i][0][1])
            for i in range(n-1,-1,-1):
                restOrdering = set(ordering[i][1][1]) & remainingActions
                if restOrdering != set():
                    ranking.append(list(restOrdering))
                    remainingActions = remainingActions - restOrdering
        rankcopy = list(ranking)
        for i in range(len(rankcopy)-1):
            if rankcopy[i] == rankcopy[i+1]:
                if Debug:
                    print('double',rankcopy[i])
                ranking.remove(rankcopy[i])
        if not Descending:
            ranking.reverse()
        if Comments:
            print(rankcopy)
            print(ranking)
        return ranking
            
    
    def showOrderedRelationTable(self,direction="decreasing",originalRelation=False):
        """
        Showing the relation table in decreasing (default) or increasing order.
        """
        if direction == "decreasing":
            Descending = True
        else:
            Descending = False
        weakOrdering = self.computeQsRbcRanking(Descending=Descending)
        actionsList = []
        for ch in weakOrdering:
            ch.sort()
            for x in ch:
                actionsList.append(x)
        if len(actionsList) != len(self.actions):
            print('Error: missing or double actions!')
        if originalRelation:
            showRelation = self.originalRelation
        else:
            showRelation = self.relation
            
        Digraph.showRelationTable(self,actionsSubset=actionsList,\
                                relation=showRelation,\
                                Sorted=False,\
                                ReflexiveTerms=False)

##    def showActionCategories(self,action,Debug=False,Comments=True):
##        """
##        Renders the union of categories in which the given action is sorted positively or null into.
##        Returns a tuple : action, lowest category key, highest category key, membership credibility !
##        """
##        Med = self.valuationdomain['med']
##        sorting = self.computeSortingCharacteristics(action=action,Comments=Debug)
##        keys = []
##        for c in self.orderedCategoryKeys():
##            if sorting[action][c]['categoryMembership'] >= Med:
##                if sorting[action][c]['lowLimit'] > Med:
##                    lowLimit = sorting[action][c]['lowLimit']
##                if sorting[action][c]['notHighLimit'] > Med:
##                    notHighLimit = sorting[action][c]['notHighLimit']
##                keys.append(c)
##                if Debug:
##                    print(action, c, sorting[action][c])
##        n = len(keys)
##        credibility = min(lowLimit,notHighLimit)
##        if n == 0:
##            return None
##        elif n == 1:
##            if Comments:
##                print('%s in %s - %s with credibility: %.2f' % (action,\
##                                     self.categories[keys[0]]['lowLimit'],\
##                                     self.categories[keys[0]]['highLimit'],\
##                                     credibility) )
##            return action,\
##                    keys[0],\
##                    keys[0],\
##                    credibility
##        else:
##            if Comments:
##                print('%s in %s - %s with credibility: %.2f' % (action,\
##                                     self.categories[keys[0]]['lowLimit'],\
##                                     self.categories[keys[-1]]['highLimit'],\
##                                     credibility) )
##            return action,\
##                    keys[0],\
##                    keys[-1],\
##                    credibility            
##
##    def showActionsSortingResult(self,actionSubset=None):
##        """
##        shows the quantiles sorting result all (default) of a subset of the decision actions.
##        """
##        if actionSubset == None:
##            actions = [x for x in self.actions]
##        else:
##            actions = [x for x in actionSubset]
##        actions.sort()
##        print('Quantiles sorting result per decision action')
##        for x in actions:
##            self.showActionCategories(x)

    def showQsRbcRanking(self,Descending=True):
        """
        show the ranking-by-sorting refinement of the quantiles sorting result
        """
        print(self.computeQsRbcRanking(Descending=Descending,
                                       Comments=False))

    def exportGraphViz(self,fileName=None,direction='decreasing',\
                       noSilent=True,graphType='png',\
                       graphSize='7,7',\
                       fontSize=10, Debug=False):
        """
        export GraphViz dot file for weak order (Hasse diagram) drawing
        filtering from SortingDigraph instances.
        """
        import os
        from copy import deepcopy

        def _safeName(t0):
            try:
                t = t0.split(sep="-")
                t1 = t[0]
                n = len(t)
                if n > 1:
                    for i in range(1,n):
                        t1 += '%s%s' % ('_',t[i])
                return t1
            except:
                print('Error in nodeName: %s !!' % t0, type(t0))
                return t0
                
##        if direction == 'decreasing':
##            ordering = self.computeQsRbcRanking(Descending=True)
##        else:
##            ordering = self.computeQsRbcRanking(Descending=False)
##        if Debug:
##            print(ordering)
        ordering = self.preOrdering
                    
        if noSilent:
            print('*---- exporting a dot file for GraphViz tools ---------*')
        actionKeys = [x for x in self.actions]
        n = len(actionKeys)
        relation = self.relation
        Med = self.valuationdomain['med']
        i = 0
        if fileName == None:
            name = self.name
        else:
            name = fileName
        dotName = name+'.dot'
        if noSilent:
            print('Exporting to '+dotName)
##        if bestChoice != set():
##            rankBestString = '{rank=max; '
##        if worstChoice != set():
##            rankWorstString = '{rank=min; '
        fo = open(dotName,'w')
        fo.write('digraph G {\n')
        fo.write('graph [ bgcolor = cornsilk, ordering = out, fontname = "Helvetica-Oblique",\n fontsize = 12,\n label = "')
        fo.write('\\QuantilesRanking (graphviz)\\n R. Bisdorff, 2014", size="')
        fo.write(graphSize),fo.write('",fontsize=%d];\n' % fontSize)
        # nodes
        for x in actionKeys:
            try:
                nodeName = self.actions[x]['shortName']
            except:
                nodeName = str(x)
            node = '%s [shape = "circle", label = "%s", fontsize=%d];\n'\
                   % (str(_safeName(x)),_safeName(nodeName),fontSize)
            fo.write(node)
        # same ranks for Hasses equivalence classes
        k = len(ordering)
        for i in range(k):
            sameRank = '{ rank = same; '
            ich = ordering[i]
            for x in ich:
                sameRank += str(_safeName(x))+'; '
            sameRank += '}\n'
            print(i,sameRank)
            fo.write(sameRank)
        # save original relation
        originalRelation = deepcopy(self.relation)
        
        self.closeTransitive(Reverse=True)
        for i in range(k-1):
            ich = ordering[i]
            for x in ich:
                for j in range(i+1,k):
                    jch = ordering[j]
                    for y in jch:
                        #edge = 'n'+str(i+1)+'-> n'+str(i+2)+' [dir=forward,style="setlinewidth(1)",color=black, arrowhead=normal] ;\n'
                        if self.relation[x][y] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(x),_safeName(y),1,arcColor)
                            fo.write(edge)
                        elif self.relation[y][x] > self.valuationdomain['med']:
                            arcColor = 'black'
                            edge = '%s-> %s [style="setlinewidth(%d)",color=%s] ;\n' % (_safeName(y),_safeName(x),1,arcColor)
                            fo.write(edge)
                                                  
        fo.write('}\n \n')
        fo.close()
        # restore original relation
        self.relation = deepcopy(originalRelation)
        
        commandString = 'dot -Grankdir=TB -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
            #commandString = 'dot -T'+graphType+' ' +dotName+' -o '+name+'.'+graphType
        if noSilent:
            print(commandString)
        try:
            os.system(commandString)
        except:
            if noSilent:
                print('graphViz tools not avalaible! Please check installation.')

           
#----------test SortingDigraph class ----------------
if __name__ == "__main__":
    from time import time
    from perfTabs import *
    from outrankingDigraphs import *
    from sortingDigraphs import *
    print("""
    ****************************************************
    * Python sortingDigraphs module                    *
    * depends on BipolarOutrankingDigraph and          *
    * $Revision$                                 *
    * Copyright (C) 2010 Raymond Bisdorff              *
    * The module comes with ABSOLUTELY NO WARRANTY     *
    * to the extent permitted by the applicable law.   *
    * This is free software, and you are welcome to    *
    * redistribute it if it remains free software.     *
    ****************************************************
    """)

    print('*-------- Testing class and methods -------')

    #t = XMCDA2PerformanceTableau('uniSorting')
    #t = XMCDA2PerformanceTableau('spiegel2004')
    t = RandomCBPerformanceTableau(numberOfActions=50,
                                   numberOfCriteria=7,
                                   weightDistribution='equiobjectives')
    t.saveXMCDA2('test',servingD3=False)
##    qs0 = QuantilesSortingDigraph(t,100)
##    qs0.showOrderedRelationTable()
##    qs0.exportGraphViz('qs0')
##    qs0.showSorting()
##    
##    qsh = _OptimalHarmonicQuantilesSortingDigraph(t,
##                                  LowerClosed=True,
##                                  PrefThresholds=False,
##                                  Threading=False,
##                                  Prudent=False,
##                                  Debug=False)
##    qsh.showSorting()
##    qsh.exportGraphViz(graphType="pdf")
##    qsopt = OptimalQuantilesSortingDigraph(t,
##                                    minQuantiles=4,
##                                    maxQuantiles=50,
##                                    LowerClosed=True,
##                                    PrefThresholds=False,
##                                    Prudent=False,       
##                                    Threading=False,
##                                    Debug=True)
##    qsopt.showSorting()
##    qsopt.exportGraphViz(graphType="pdf")
##    #qsh.showCriteriaCategoryLimits()
    t = XMCDA2PerformanceTableau('test')
##    print('==>> Without Threading')
##    qso = QuantilesSortingDigraph(t,Threading=False,Debug=False)
##    qso.showSorting()
##    print('==>> With Threading')
##    qso = QuantilesSortingDigraph(t,CompleteOutranking=False,Threading=True,Debug=False)
##    qso.showSorting()
    qsrbc = QuantilesRankingDigraph(t,Threading=True,Debug=False)
    #qsrbc.showOrderedRelationTable()
    qsrbc.exportGraphViz()
##    qsrbc = QuantilesRankingDigraph(t,Threading=False,Debug=False)
##    #qsrbc.showOrderedRelationTable()
##    qsrbc.showQsRbcRanking()
    g = BipolarOutrankingDigraph(t,Normalized=True)
    print(g.computeOrdinalCorrelation(qsrbc))
    #qsrbc.exportGraphViz()

    print('*------------------*')
    print('If you see this line all tests were passed successfully :-)')
    print('Enjoy !')

    print('*************************************')
    print('* R.B. december 2010                *')
    print('* $Revision$                  *')
    print('*************************************')

#############################
# Log record for changes:
# $Log: sortingDigraphs.py,v $
#############################
